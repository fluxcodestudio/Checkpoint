---
phase: 08-monitoring-enhancements
plan: 03
type: execute
---

<objective>
Add configurable alert thresholds, notification preferences, and quiet hours.

Purpose: Give users control over when and how they're alerted â€” reduce notification fatigue while ensuring critical issues aren't missed.
Output: Alert configuration in backup-config, quiet hours support, and per-project notification settings.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-dashboard-monitoring/06-01-SUMMARY.md
@.planning/phases/08-monitoring-enhancements/08-01-SUMMARY.md
@.planning/phases/08-monitoring-enhancements/08-02-SUMMARY.md

@lib/backup-lib.sh
@lib/global-status.sh

**Tech available:** bash config sourcing, osascript notifications
**Established patterns:** .backup-config.sh sourcing, health thresholds (24h/72h)
**Prior decisions:** Health thresholds: >24h warning, >72h error
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add configurable alert thresholds</name>
  <files>lib/backup-lib.sh, lib/global-status.sh</files>
  <action>
1. Add alert configuration section to backup-lib.sh:
```bash
# ==============================================================================
# ALERT CONFIGURATION
# ==============================================================================

# Health thresholds (hours without backup)
# Can be overridden in .backup-config.sh
: "${ALERT_WARNING_HOURS:=24}"
: "${ALERT_ERROR_HOURS:=72}"

# Notification preferences
# Can be overridden in .backup-config.sh
: "${NOTIFY_ON_SUCCESS:=false}"         # Only notify success after recovery
: "${NOTIFY_ON_WARNING:=true}"          # Notify on stale backups
: "${NOTIFY_ON_ERROR:=true}"            # Notify on failures
: "${NOTIFY_ESCALATION_HOURS:=3}"       # Hours between repeated alerts
: "${NOTIFY_SOUND:=default}"            # default, Basso, Glass, Hero, Pop, or none

# Per-project notification override
# Set in project's .backup-config.sh
: "${PROJECT_NOTIFY_ENABLED:=true}"     # Enable/disable for this project
```

2. Update global-status.sh to use configurable thresholds:
```bash
# Replace hardcoded values with config variables
get_project_health() {
    local project_path="$1"
    local age=$(get_project_backup_age "$project_path")

    # Load project-specific thresholds if available
    local config_file="$project_path/.backup-config.sh"
    local warning_hours=${ALERT_WARNING_HOURS:-24}
    local error_hours=${ALERT_ERROR_HOURS:-72}

    if [[ -f "$config_file" ]]; then
        local project_warning project_error
        project_warning=$(source "$config_file" 2>/dev/null; echo "${ALERT_WARNING_HOURS:-}")
        project_error=$(source "$config_file" 2>/dev/null; echo "${ALERT_ERROR_HOURS:-}")
        [[ -n "$project_warning" ]] && warning_hours="$project_warning"
        [[ -n "$project_error" ]] && error_hours="$project_error"
    fi

    local warning_seconds=$((warning_hours * 3600))
    local error_seconds=$((error_hours * 3600))

    if [[ "$age" == "-1" ]]; then
        echo "error"
    elif [[ $age -gt $error_seconds ]]; then
        echo "error"
    elif [[ $age -gt $warning_seconds ]]; then
        echo "warning"
    else
        echo "healthy"
    fi
}
```

3. Update notification functions to respect preferences:
```bash
notify_backup_failure() {
    # Check if notifications enabled for this project
    if [[ "${PROJECT_NOTIFY_ENABLED:-true}" != "true" ]]; then
        return 0
    fi

    # Check if error notifications enabled
    if [[ "${NOTIFY_ON_ERROR:-true}" != "true" ]]; then
        return 0
    fi

    # Existing escalation logic...
    # Use NOTIFY_ESCALATION_HOURS instead of hardcoded 3
    local escalation_hours=${NOTIFY_ESCALATION_HOURS:-3}
    # ...
}
```
  </action>
  <verify>
1. Source backup-lib.sh with custom thresholds: `ALERT_WARNING_HOURS=12 source lib/backup-lib.sh`
2. Check get_project_health() uses configured threshold
3. Set `PROJECT_NOTIFY_ENABLED=false` and verify notifications suppressed
  </verify>
  <done>
- Alert thresholds configurable via env vars
- Per-project override support
- Notification preferences (success/warning/error toggles)
- Escalation interval configurable
  </done>
</task>

<task type="auto">
  <name>Task 2: Add quiet hours support</name>
  <files>lib/backup-lib.sh</files>
  <action>
1. Add quiet hours configuration:
```bash
# ==============================================================================
# QUIET HOURS
# ==============================================================================

# Quiet hours suppress non-critical notifications
# Format: START_HOUR-END_HOUR in 24h format (e.g., "22-07" = 10pm to 7am)
: "${QUIET_HOURS:=}"                    # Empty = no quiet hours
: "${QUIET_HOURS_BLOCK_ERRORS:=false}"  # Still notify critical errors during quiet hours
```

2. Add quiet hours check function:
```bash
# Check if currently in quiet hours
# Returns: 0 if in quiet hours, 1 if not
is_quiet_hours() {
    local quiet_hours="${QUIET_HOURS:-}"

    # No quiet hours configured
    [[ -z "$quiet_hours" ]] && return 1

    # Parse start and end hours
    local start_hour="${quiet_hours%%-*}"
    local end_hour="${quiet_hours##*-}"

    # Validate format
    if ! [[ "$start_hour" =~ ^[0-9]+$ ]] || ! [[ "$end_hour" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    local current_hour=$(date +%H)
    current_hour=${current_hour#0}  # Remove leading zero

    # Handle overnight quiet hours (e.g., 22-07)
    if [[ $start_hour -gt $end_hour ]]; then
        # Quiet if after start OR before end
        if [[ $current_hour -ge $start_hour ]] || [[ $current_hour -lt $end_hour ]]; then
            return 0
        fi
    else
        # Normal range (e.g., 09-17)
        if [[ $current_hour -ge $start_hour ]] && [[ $current_hour -lt $end_hour ]]; then
            return 0
        fi
    fi

    return 1
}

# Check if notification should be sent (considering quiet hours)
# Args: $1 = urgency level (critical, high, medium, low)
should_notify() {
    local urgency="${1:-medium}"

    # Always notify critical if configured
    if [[ "$urgency" == "critical" ]] && [[ "${QUIET_HOURS_BLOCK_ERRORS:-false}" != "true" ]]; then
        return 0
    fi

    # Check quiet hours
    if is_quiet_hours; then
        return 1  # Suppress notification
    fi

    return 0
}
```

3. Integrate quiet hours into notification functions:
```bash
send_notification() {
    local title="$1"
    local message="$2"
    local sound="${3:-default}"
    local urgency="${4:-medium}"

    # Check if should notify (quiet hours, preferences)
    if ! should_notify "$urgency"; then
        # Log suppressed notification
        echo "[$(date)] Notification suppressed (quiet hours): $title" >> "${BACKUP_LOG_FILE:-/dev/null}"
        return 0
    fi

    # Handle sound preference
    if [[ "${NOTIFY_SOUND:-default}" == "none" ]]; then
        sound=""
    elif [[ "${NOTIFY_SOUND:-default}" != "default" ]]; then
        sound="${NOTIFY_SOUND}"
    fi

    # Send notification (existing osascript logic)
    if [[ -n "$sound" ]]; then
        osascript -e "display notification \"$message\" with title \"$title\" sound name \"$sound\"" 2>/dev/null || true
    else
        osascript -e "display notification \"$message\" with title \"$title\"" 2>/dev/null || true
    fi
}
```

4. Update notify_backup_failure() to pass urgency:
```bash
# Pass "critical" for first failure, "high" for escalated
send_notification "$title" "$message" "Basso" "critical"
```
  </action>
  <verify>
1. `QUIET_HOURS="22-07" is_quiet_hours && echo "quiet" || echo "active"` (test during appropriate time)
2. Set QUIET_HOURS and verify notifications suppressed
3. Set QUIET_HOURS_BLOCK_ERRORS=false and verify critical alerts still send
4. Verify suppressed notifications logged
  </verify>
  <done>
- Quiet hours configuration (START-END format)
- Overnight range support (e.g., 22-07)
- Critical errors can bypass quiet hours
- Suppressed notifications logged
- Phase 8 complete
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ALERT_WARNING_HOURS and ALERT_ERROR_HOURS configurable
- [ ] Per-project notification overrides work
- [ ] Quiet hours suppress non-critical notifications
- [ ] Critical errors bypass quiet hours (when configured)
- [ ] All configuration via environment variables (no new files)
</verification>

<success_criteria>
- All tasks completed
- Alert thresholds user-configurable
- Quiet hours reduce notification fatigue
- Critical alerts still reach users
- Phase 8: Monitoring Enhancements complete
</success_criteria>

<output>
After completion, create `.planning/phases/08-monitoring-enhancements/08-03-SUMMARY.md`

Final summary should include:
- New configuration options added
- Notification behavior changes
- Backward compatibility notes
</output>
