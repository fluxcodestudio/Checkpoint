---
phase: 16-backup-verification
plan: 01
type: execute
---

<objective>
Create the core verification library module with tiered verification (quick/full), error codes, and persistent JSON manifest generation at backup time.

Purpose: Provide the verification engine that all UIs (CLI, dashboard) will call, plus ensure every backup produces a machine-readable manifest for later auditing.
Output: lib/features/verification.sh module, EVER error codes, persistent .checkpoint-manifest.json written by backup-now.sh
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-backup-verification/16-RESEARCH.md

# Key source files (read before implementing):
@lib/backup-lib.sh
@lib/core/error-codes.sh
@lib/core/output.sh
@lib/ops/file-ops.sh
@lib/ops/state.sh
@lib/features/restore.sh
@bin/backup-now.sh

# Prior phase context:
@.planning/phases/11-modularize-foundation/11-03-SUMMARY.md
@.planning/phases/15-linux-systemd-support/15-01-SUMMARY.md

**Tech stack available:** bash 3.2+, shasum/sha256sum, gunzip, sqlite3, rclone (optional), file command
**Established patterns:**
- Module loader: thin file in backup-lib.sh sources all modules in dependency order
- Include guard: `[ -n "${_VAR:-}" ] && return || readonly _VAR=1`
- JSON output: manual construction with json_kv(), json_kv_num(), json_kv_bool() from output.sh (NO jq)
- Error codes: E{CATEGORY}{NNN} format with description + suggestion functions
- Platform portability: get_file_size(), get_file_mtime() from lib/platform/compat.sh
- State JSON: flat structure, snake_case keys, severity object (see lib/ops/state.sh write_backup_state())

**Constraining decisions:**
- Phase 11: Module loader pattern — new module added to features/ section of backup-lib.sh
- Phase 15: Use portable stat wrappers, not raw stat commands
- No jq dependency — use json_kv() helpers for all JSON construction
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verification module + error codes</name>
  <files>lib/features/verification.sh, lib/core/error-codes.sh, lib/backup-lib.sh</files>
  <action>
**1. Add error codes to lib/core/error-codes.sh:**

Add 6 verification error codes following existing E{CATEGORY}{NNN} pattern. Insert after the existing EFILE section:
- EVER001: "File missing from backup" / suggestion: "Run backup-now to re-backup missing files"
- EVER002: "File size mismatch" / suggestion: "Re-run backup; if persistent, check disk health"
- EVER003: "File hash mismatch (possible corruption)" / suggestion: "Re-run backup with --force; check disk for errors"
- EVER004: "Database integrity check failed" / suggestion: "Re-backup database; check source database health"
- EVER005: "Manifest missing or corrupt" / suggestion: "Run backup-now to generate fresh manifest"
- EVER006: "Cloud sync verification failed" / suggestion: "Check network connectivity and rclone configuration"

Add these to the get_error_description(), get_error_suggestion(), and any lookup arrays following the exact existing pattern.

**2. Create lib/features/verification.sh:**

Follow existing module conventions:
- Include guard: `[ -n "${_CHECKPOINT_VERIFICATION:-}" ] && return || readonly _CHECKPOINT_VERIFICATION=1`
- Header comment with @requires and @provides

Functions to implement:

**verify_backup_quick(backup_dir)** — Quick mode (default):
- Read manifest from `$backup_dir/.checkpoint-manifest.json` (if missing, fall back to scanning backup dir)
- For each file entry in manifest: check existence in backup dir, check size matches
- For each database entry: run `gunzip -t` on .db.gz files, run `sqlite3 PRAGMA quick_check` on decompressed copy
- Check manifest file count matches actual file count in backup/files/
- Track pass/fail/warning counts
- Return 0 if all pass, 1 if any fail

**verify_backup_full(backup_dir)** — Full mode:
- Everything in quick mode, plus:
- SHA256 hash verification of all backed-up files (bypass hash cache — compute fresh with `shasum -a 256` directly, NOT via get_file_hash() which uses mtime cache)
- Full `PRAGMA integrity_check` (not quick_check) on databases
- Schema readability check (`sqlite3 .schema`)
- Table count validation (must have >0 tables)
- Check for orphan .db-wal/.db-shm files alongside backups (WARNING if found)
- Minimum size sanity check on .db.gz files (< 100 bytes = WARNING)

**verify_cloud_backup(backup_dir)** — Cloud verification (opt-in):
- Check CLOUD_ENABLED is true, return 0 with skip message if not
- Check rclone is installed (check_rclone_installed or command -v rclone)
- Build full remote path: `${CLOUD_REMOTE_NAME}:${CLOUD_BACKUP_PATH}`
- Run `rclone check "$backup_dir" "$full_path" --one-way --size-only` with 60s timeout
- Parse exit code: 0=match, non-zero=differences found
- Return 0 if match, 1 if differences

**generate_verification_report(results_array, output_mode)** — Report generator:
- output_mode "human": Formatted report with aligned columns using printf (see 16-RESEARCH.md Pattern 3)
- output_mode "json": JSON using json_kv/json_kv_num/json_kv_bool helpers — structure:
  ```
  {
    "timestamp": "ISO8601",
    "project": "name",
    "mode": "quick|full",
    "overall_status": "pass|fail|warning",
    "checks": {
      "files": {"total": N, "passed": N, "failed": N, "warnings": N},
      "databases": {"total": N, "passed": N, "failed": N, "warnings": N},
      "cloud": {"status": "pass|fail|skipped", "details": "..."}
    },
    "failures": [{"path": "...", "error_code": "EVER00X", "message": "..."}],
    "summary": {"total_checks": N, "passed": N, "failed": N, "warnings": N}
  }
  ```
- output_mode "compact": Single line summary (e.g., "PASS: 47 files, 2 databases verified")

**read_manifest(backup_dir)** — Manifest reader:
- Read and parse .checkpoint-manifest.json
- Return file entries and database entries via global arrays (bash can't return arrays from functions — use global arrays like MANIFEST_FILES, MANIFEST_DATABASES following existing codebase convention)
- Handle missing manifest gracefully (return 1, caller falls back to directory scan)

**Check for active backup before verifying:** Read lock file at standard lock location. If lock exists and PID is alive, print warning and exit 2 (cannot verify during active backup — race condition per 16-RESEARCH.md Pitfall 2).

**3. Register in lib/backup-lib.sh:**

Add `source "$_CHECKPOINT_LIB_DIR/features/verification.sh"` in the features section, after the github-auth.sh line.
  </action>
  <verify>
- `bash -n lib/features/verification.sh` — syntax check passes
- `bash -n lib/core/error-codes.sh` — syntax check passes
- `bash -n lib/backup-lib.sh` — syntax check passes (module loads)
- `source lib/backup-lib.sh` in a test context doesn't error
- grep confirms EVER001-EVER006 exist in error-codes.sh
- grep confirms verification.sh is sourced in backup-lib.sh
  </verify>
  <done>
- verification.sh exists with include guard, all 6 functions implemented
- 6 EVER error codes registered in error-codes.sh with descriptions and suggestions
- backup-lib.sh sources verification.sh
- All 3 files pass bash -n syntax check
  </done>
</task>

<task type="auto">
  <name>Task 2: Persist JSON manifest in backup-now.sh</name>
  <files>bin/backup-now.sh</files>
  <action>
Modify backup-now.sh to persist a JSON manifest at backup completion instead of deleting the temp manifest.

**Current flow (lines ~742-963):**
1. `manifest_file=$(mktemp)` — creates temp file
2. Loop writes `file|size` entries (pipe-delimited)
3. Post-backup verification reads manifest
4. `rm -f "$manifest_file"` — deletes it

**New flow:**

1. Keep the existing temp manifest for the post-backup verification loop (don't change that working code)
2. AFTER the post-backup verification succeeds, call a new function `persist_manifest_json()` that:
   - Creates `$BACKUP_DIR/.checkpoint-manifest.json`
   - Iterates backed-up files in `$FILES_DIR`, collecting: relative path (relative to $BACKUP_DIR), size via `get_file_size`, SHA256 hash via `get_file_hash` (cache is fine here — this is backup-time, not verification-time)
   - Iterates database backups in `$DATABASE_DIR`, collecting: relative path, size, hash, table count (decompress to temp, run `sqlite3 "SELECT count(*) FROM sqlite_master WHERE type='table';"`, clean up temp)
   - Writes JSON manifest using json_kv/json_kv_num helpers:
    ```json
    {
      "version": 1,
      "timestamp": "ISO8601",
      "project": "$PROJECT_NAME",
      "backup_id": "$BACKUP_ID",
      "files": [
        {"path": "files/src/app.js", "size": 2048, "sha256": "abc123..."}
      ],
      "databases": [
        {"path": "databases/dev.db.gz", "size": 4096, "sha256": "def456...", "tables": 12}
      ],
      "totals": {"files": N, "databases": N}
    }
    ```
   - Write atomically: write to temp file first, then mv to final location
3. Keep the existing `rm -f "$manifest_file"` for the temp file cleanup
4. The `persist_manifest_json` function should live in `lib/features/verification.sh` (already created in Task 1) so it's reusable. Call it from backup-now.sh after the verification loop.

**Important:**
- Do NOT refactor the existing post-backup verification loop — it works and is battle-tested
- Add the manifest persistence AFTER the existing verification, BEFORE the temp file cleanup
- Use `$BACKUP_ID` variable that already exists in backup-now.sh scope for the backup_id field
- Handle errors gracefully — if manifest generation fails, log warning but don't fail the backup (manifest is supplementary, not critical path)
- Wrap in `if` block: `if type persist_manifest_json &>/dev/null; then ... fi` so backup-now.sh doesn't break if verification.sh isn't loaded (defensive)
  </action>
  <verify>
- `bash -n bin/backup-now.sh` — syntax check passes
- grep confirms `persist_manifest_json` is called in backup-now.sh
- grep confirms `.checkpoint-manifest.json` is referenced in verification.sh
- Run a test backup on a small project directory and verify .checkpoint-manifest.json is created in the backup dir with valid JSON structure
  </verify>
  <done>
- backup-now.sh calls persist_manifest_json after post-backup verification
- .checkpoint-manifest.json is created in $BACKUP_DIR with version, timestamp, project, files[], databases[], totals
- Existing post-backup verification loop is unchanged
- Manifest generation failure doesn't break backup flow
- bash -n passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/features/verification.sh` passes
- [ ] `bash -n lib/core/error-codes.sh` passes
- [ ] `bash -n lib/backup-lib.sh` passes
- [ ] `bash -n bin/backup-now.sh` passes
- [ ] EVER001-EVER006 error codes exist with descriptions and suggestions
- [ ] verification.sh has include guard and all 6 functions
- [ ] backup-lib.sh sources verification.sh
- [ ] backup-now.sh persists JSON manifest without breaking existing verification
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No bash syntax errors introduced
- Verification module follows established module conventions (include guard, @requires header)
- Error codes follow existing E{CATEGORY}{NNN} pattern
- JSON output uses json_kv helpers (no jq dependency)
- Manifest persisted atomically with graceful error handling
</success_criteria>

<output>
After completion, create `.planning/phases/16-backup-verification/16-01-SUMMARY.md`
</output>
