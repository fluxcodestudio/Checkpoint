---
phase: 15-linux-systemd-support
plan: 03
type: execute
---

<objective>
Create unified daemon management abstraction layer and systemd service templates.

Purpose: The project currently has launchctl calls hardcoded across 10+ scripts. This plan creates `lib/platform/daemon-manager.sh` — a unified API for daemon install/uninstall/start/stop/status/restart that dispatches to launchd (macOS), systemd (Linux), or cron (fallback). Also creates systemd service templates parallel to existing plist templates.
Output: `lib/platform/daemon-manager.sh` (300+ lines), 4 systemd/cron template files in `templates/`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-linux-systemd-support/15-RESEARCH.md
@.planning/phases/15-linux-systemd-support/15-01-SUMMARY.md
@.planning/phases/15-linux-systemd-support/15-02-SUMMARY.md

# Existing platform abstraction to mirror:
@lib/platform/file-watcher.sh
@lib/platform/compat.sh

# Existing plist templates (new systemd templates parallel these):
@templates/launchd-watcher.plist
@templates/com.checkpoint.watchdog.plist

# Scripts that currently contain inline launchd code (for understanding what daemon-manager must support):
@bin/install-global.sh
@bin/install.sh
@bin/checkpoint-watchdog.sh

**Tech stack available:** lib/platform/ abstraction layer, template-based service generation
**Established patterns:** detect-and-dispatch (file-watcher.sh), include-guard standalone modules
**Constraining decisions:**
- Research: Use `/run/systemd/system` dir check for init detection (systemd dev recommendation)
- Research: Use `Type=simple` for long-running daemons (watcher), systemd timer for periodic (hourly backup)
- Research: Use `checkpoint-*` naming for systemd services, `com.checkpoint.*` for launchd
- Research: Set explicit `StartLimitIntervalSec=300`, `StartLimitBurst=5`, `RestartSec=5s` to avoid rate limiting
- Research: systemd user services go in `~/.config/systemd/user/`
- Research: Don't hand-roll: restart policies (use systemd Restart=), log rotation (use journald), process monitoring (use is-active)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/platform/daemon-manager.sh</name>
  <files>lib/platform/daemon-manager.sh</files>
  <action>
Create `lib/platform/daemon-manager.sh` following the same standalone module pattern as `file-watcher.sh`.

**Init System Detection:**
```
detect_init_system() → "launchd" | "systemd" | "cron"
```
- Darwin → "launchd"
- Linux + `/run/systemd/system` exists → "systemd"
- Linux + fallback readlink /proc/1/exe check → "systemd" if matches
- Everything else → "cron"
- Cache result in `_DAEMON_INIT_SYSTEM` module variable

**Public API (all dispatch to platform backends):**

1. `install_daemon(service_name, script_path, project_dir, project_name, service_type)` — service_type is "watcher" | "daemon" | "watchdog"
   - launchd: Generate plist from template (templates/launchd-watcher.plist or com.checkpoint.watchdog.plist), copy to ~/Library/LaunchAgents/, launchctl load
   - systemd: Generate .service from template (sed placeholder replacement), copy to ~/.config/systemd/user/, daemon-reload, enable, start
   - cron: Add crontab entry for periodic execution (*/5 for watcher, 0 * for hourly daemon)

2. `uninstall_daemon(service_name)` — Removes daemon
   - launchd: launchctl unload, rm plist from ~/Library/LaunchAgents/
   - systemd: systemctl --user stop, disable, rm service file, daemon-reload
   - cron: Remove matching crontab line

3. `start_daemon(service_name)` — Start stopped daemon
   - launchd: launchctl load -w plist
   - systemd: systemctl --user start
   - cron: no-op (cron runs on schedule)

4. `stop_daemon(service_name)` — Stop running daemon
   - launchd: launchctl unload plist
   - systemd: systemctl --user stop
   - cron: kill process if running (find PID from lock file)

5. `restart_daemon(service_name)` — Restart daemon
   - launchd: unload + load plist
   - systemd: systemctl --user restart
   - cron: stop + start

6. `status_daemon(service_name)` — Check if daemon is running (return 0=running, 1=stopped)
   - launchd: launchctl list | grep service_name
   - systemd: systemctl --user is-active --quiet
   - cron: crontab -l | grep + check PID

7. `list_daemons(pattern)` — List matching daemons
   - launchd: launchctl list | grep pattern
   - systemd: systemctl --user list-units --type=service | grep pattern
   - cron: crontab -l | grep pattern

**Service name mapping:**
- `_daemon_launchd_name(service_name)` → `com.checkpoint.${service_name}` or `com.claudecode.backup.${service_name}` (support both naming conventions for backwards compat)
- `_daemon_systemd_name(service_name)` → `checkpoint-${service_name}`
- Plist path: `$HOME/Library/LaunchAgents/{launchd_name}.plist`
- Service path: `$HOME/.config/systemd/user/{systemd_name}.service`

**Template processing:**
- `_daemon_apply_template(template_file, output_file, project_name, project_dir, script_path)` — sed replacement of placeholders: PROJECT_NAME_PLACEHOLDER, PROJECT_DIR_PLACEHOLDER, SCRIPT_PATH_PLACEHOLDER, HOME_PLACEHOLDER, INSTALL_DIR_PLACEHOLDER

**Implementation notes:**
- Use `_DAEMON_MANAGER_LOADED` include guard
- Cache `detect_init_system()` result to avoid repeated checks
- All launchctl calls use `2>/dev/null || true` for error suppression (matching existing pattern)
- systemd commands use `--user` flag (user-level services, no root)
- mkdir -p `$HOME/.config/systemd/user` before first systemd install
- Bash 3.2 compatible: `[ ]` not `[[ ]]`, no associative arrays
- The launchd backend must handle BOTH `com.checkpoint.*` (new) and `com.claudecode.backup.*` (legacy) naming
  </action>
  <verify>bash -n lib/platform/daemon-manager.sh passes; sourcing the file and calling detect_init_system returns "launchd" (on macOS dev machine); all 7 public functions are defined (grep "^[a-z].*() {" counts 7+)</verify>
  <done>daemon-manager.sh exists with detect_init_system + 7 public API functions + launchd/systemd/cron backends; passes syntax check; init detection returns correct value on macOS</done>
</task>

<task type="auto">
  <name>Task 2: Create systemd service templates and cron fallback template</name>
  <files>templates/systemd-watcher.service, templates/systemd-daemon.service, templates/systemd-daemon.timer, templates/systemd-watchdog.service, templates/cron-backup.crontab</files>
  <action>
Create template files parallel to existing plist templates. Use the same placeholder convention (PROJECT_NAME_PLACEHOLDER, etc.) already used in launchd-watcher.plist.

**templates/systemd-watcher.service** — File watcher (long-running):
```ini
[Unit]
Description=Checkpoint File Watcher - PROJECT_NAME_PLACEHOLDER
StartLimitIntervalSec=300
StartLimitBurst=5

[Service]
Type=simple
ExecStart=/bin/bash SCRIPT_PATH_PLACEHOLDER
WorkingDirectory=PROJECT_DIR_PLACEHOLDER
Environment=PATH=/usr/local/bin:/usr/bin:/bin:HOME_PLACEHOLDER/.local/bin
EnvironmentFile=-HOME_PLACEHOLDER/.config/checkpoint/env
Restart=on-failure
RestartSec=5s
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
```

**templates/systemd-daemon.service** — Hourly backup (triggered by timer):
```ini
[Unit]
Description=Checkpoint Backup - PROJECT_NAME_PLACEHOLDER

[Service]
Type=oneshot
ExecStart=/bin/bash SCRIPT_PATH_PLACEHOLDER
WorkingDirectory=PROJECT_DIR_PLACEHOLDER
Environment=PATH=/usr/local/bin:/usr/bin:/bin:HOME_PLACEHOLDER/.local/bin
EnvironmentFile=-HOME_PLACEHOLDER/.config/checkpoint/env
StandardOutput=journal
StandardError=journal
```
Note: No [Install] section — this service is activated by the timer unit.

**templates/systemd-daemon.timer** — Timer for hourly backup:
```ini
[Unit]
Description=Checkpoint Hourly Backup Timer - PROJECT_NAME_PLACEHOLDER

[Timer]
OnBootSec=5min
OnUnitActiveSec=1h
Persistent=true

[Install]
WantedBy=timers.target
```

**templates/systemd-watchdog.service** — Watchdog monitor (long-running):
```ini
[Unit]
Description=Checkpoint Watchdog Monitor
StartLimitIntervalSec=300
StartLimitBurst=5

[Service]
Type=simple
ExecStart=/bin/bash SCRIPT_PATH_PLACEHOLDER
Environment=PATH=/usr/local/bin:/usr/bin:/bin:HOME_PLACEHOLDER/.local/bin
EnvironmentFile=-HOME_PLACEHOLDER/.config/checkpoint/env
Restart=on-failure
RestartSec=10s
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
```

**templates/cron-backup.crontab** — Reference template for cron fallback (not installed directly, used as documentation):
```
# Checkpoint Backup - PROJECT_NAME_PLACEHOLDER
# Installed by checkpoint daemon-manager (cron fallback)
*/5 * * * * /bin/bash SCRIPT_PATH_PLACEHOLDER >> HOME_PLACEHOLDER/.checkpoint/logs/cron-PROJECT_NAME_PLACEHOLDER.log 2>&1
```

Template notes:
- Use `EnvironmentFile=-` (dash prefix) to make env file optional — no error if missing
- `Persistent=true` on timer ensures missed runs fire on next boot
- watchdog uses longer `RestartSec=10s` since it's a monitor, not user-facing
- Watcher and watchdog use `Restart=on-failure` — only restart on crashes, not clean exits
  </action>
  <verify>All 5 template files exist in templates/; each contains expected placeholders (grep PROJECT_NAME_PLACEHOLDER); systemd service files have [Unit], [Service] sections; timer has [Timer] section; no bash syntax issues in crontab template</verify>
  <done>5 template files created: systemd-watcher.service, systemd-daemon.service, systemd-daemon.timer, systemd-watchdog.service, cron-backup.crontab; all use consistent placeholder convention matching existing plist templates</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/platform/daemon-manager.sh` passes
- [ ] `detect_init_system` returns correct value on dev machine
- [ ] All 7 public functions defined in daemon-manager.sh
- [ ] 5 template files exist in templates/
- [ ] Templates use same placeholder convention as launchd-watcher.plist
- [ ] systemd templates include StartLimitIntervalSec, RestartSec protections
</verification>

<success_criteria>

- daemon-manager.sh provides unified API for daemon lifecycle across 3 platforms
- systemd templates follow research recommendations (rate limiting, journald, EnvironmentFile)
- Timer unit used for periodic backup (idiomatic systemd)
- Cron fallback template available for non-systemd Linux
- All code Bash 3.2 compatible
</success_criteria>

<output>
After completion, create `.planning/phases/15-linux-systemd-support/15-03-SUMMARY.md`
</output>
