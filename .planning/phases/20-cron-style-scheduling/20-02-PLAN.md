---
phase: 20-cron-style-scheduling
plan: 02
type: execute
---

<objective>
Wire BACKUP_SCHEDULE config variable through all config layers, integrate scheduling library into daemon and watcher, and update status display.

Purpose: Connect the scheduling library (from 20-01) to the actual backup system so users can configure cron-style schedules that control when backups run.
Output: End-to-end cron scheduling working — user sets `BACKUP_SCHEDULE="@workhours"` in config, daemon respects it, status shows schedule info.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-cron-style-scheduling/20-RESEARCH.md
@.planning/phases/20-cron-style-scheduling/20-01-SUMMARY.md
@lib/features/scheduling.sh
@lib/core/config.sh
@bin/backup-daemon.sh
@bin/backup-watcher.sh
@bin/checkpoint.sh
@templates/backup-config.sh
@templates/backup-config.yaml
@templates/global-config-template.sh

**Tech stack available:** Pure bash, scheduling.sh library with cron_matches_now/validate_schedule/next_cron_match
**Established patterns:** Config variable wiring: DEFAULT_ in global template → config.sh parsing → per-project template → YAML mapping → validation
**Constraining decisions:**
- [Research]: BACKUP_SCHEDULE takes priority over BACKUP_INTERVAL when set. Backward compatible — BACKUP_INTERVAL still works as fallback.
- [Research]: Platform schedulers (launchd) should run more frequently when schedule mode is active. Daemon's own schedule check prevents unnecessary work.
- [Research]: Track last-run timestamp to prevent double-runs within same minute.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire BACKUP_SCHEDULE config variable across all config layers</name>
  <files>templates/backup-config.sh, templates/backup-config.yaml, templates/global-config-template.sh, lib/core/config.sh, bin/backup-config.sh</files>
  <action>
    1. templates/backup-config.sh: Add `BACKUP_SCHEDULE=""` (empty default = interval mode) in BACKUP TRIGGERS section after BACKUP_INTERVAL, with comments showing examples: `# Cron-style schedule (overrides BACKUP_INTERVAL when set)`, `# Examples: "*/30 9-17 * * 1-5"  (every 30min during work hours)`, `# Presets: @hourly, @workhours, @every-5min, @every-30min, @daily, @weekdays`

    2. templates/backup-config.yaml: Add `cron: null` under `schedule:` section (after `interval: 3600`), with comment: `# Cron expression or preset (overrides interval when set)`, `# Examples: "*/30 9-17 * * 1-5", "@workhours", "@hourly"`

    3. templates/global-config-template.sh: Add `DEFAULT_BACKUP_SCHEDULE=""` in AUTOMATION section after DEFAULT_BACKUP_INTERVAL, with comment explaining it overrides interval

    4. lib/core/config.sh:
       - In load_global_config() case statement: Add `DEFAULT_BACKUP_SCHEDULE) : "${BACKUP_SCHEDULE:=$value}" ;;`
       - In fallbacks section: Add `: "${BACKUP_SCHEDULE:=}"` (empty default)
       - In config_key_to_var(): Add `"schedule.cron") echo "BACKUP_SCHEDULE" ;;`
       - In config_var_to_key(): Add `"BACKUP_SCHEDULE") echo "schedule.cron" ;;`

    5. bin/backup-config.sh mode_validate(): Add validation for BACKUP_SCHEDULE — if non-empty, source scheduling.sh and call validate_schedule(). Show specific error for invalid expressions.
  </action>
  <verify>
    - `grep -c BACKUP_SCHEDULE templates/backup-config.sh` returns >= 1
    - `grep -c 'cron:' templates/backup-config.yaml` returns >= 1
    - `grep -c DEFAULT_BACKUP_SCHEDULE templates/global-config-template.sh` returns >= 1
    - `grep -c BACKUP_SCHEDULE lib/core/config.sh` returns >= 4
    - `bash -n lib/core/config.sh` passes
    - `bash -n bin/backup-config.sh` passes
  </verify>
  <done>BACKUP_SCHEDULE wired through all 5 config layers with YAML bidirectional mapping. Validation uses scheduling.sh validate_schedule(). Empty default preserves backward compatibility.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate scheduling into daemon and watcher</name>
  <files>bin/backup-daemon.sh, bin/backup-watcher.sh</files>
  <action>
    1. bin/backup-daemon.sh (around line 656-667):
       - Source scheduling library: `source "$CHECKPOINT_LIB/lib/features/scheduling.sh" 2>/dev/null || true` (near top where other libs are sourced)
       - Replace the interval check block with dual-mode logic:
         - If BACKUP_SCHEDULE is non-empty: call `cron_matches_now "$BACKUP_SCHEDULE"`. If no match, log "Schedule does not match current time" and exit 0. Also check dedup: if last backup was less than 60 seconds ago, exit 0 (prevent double-run in same minute).
         - If BACKUP_SCHEDULE is empty: preserve existing BACKUP_INTERVAL logic unchanged.
       - Do NOT modify the has_changes early-exit or database check logic below the interval block.

    2. bin/backup-watcher.sh should_backup_now() (around line 130-144):
       - Source scheduling library near top of file
       - In should_backup_now(): If BACKUP_SCHEDULE is non-empty, check `cron_matches_now "$BACKUP_SCHEDULE"` instead of interval math. Keep drive verification check. If BACKUP_SCHEDULE empty, keep existing interval logic.

    Important: The scheduling library source should use the same CHECKPOINT_LIB path pattern already used by the script. Guard with `2>/dev/null || true` so scripts don't break if file missing during upgrade.
  </action>
  <verify>
    - `bash -n bin/backup-daemon.sh` passes
    - `bash -n bin/backup-watcher.sh` passes
    - `grep -c 'cron_matches_now' bin/backup-daemon.sh` returns >= 1
    - `grep -c 'cron_matches_now' bin/backup-watcher.sh` returns >= 1
    - `grep -c 'BACKUP_INTERVAL' bin/backup-daemon.sh` still >= 1 (backward compat preserved)
  </verify>
  <done>Daemon and watcher use cron_matches_now() when BACKUP_SCHEDULE is set. Falls back to BACKUP_INTERVAL when BACKUP_SCHEDULE is empty. No regression for existing interval-based configs.</done>
</task>

<task type="auto">
  <name>Task 3: Update checkpoint status display with schedule info</name>
  <files>bin/checkpoint.sh</files>
  <action>
    1. In show_command_center(), find the "Automation" section (around line 135-138) that shows:
       `"    Backup Interval:       $((${DEFAULT_BACKUP_INTERVAL:-3600} / 60)) minutes"`

    2. Replace/augment with schedule-aware display:
       - If DEFAULT_BACKUP_SCHEDULE (or BACKUP_SCHEDULE for project) is non-empty: show "Backup Schedule: [expression] ([resolved if preset])" and "Next Backup: [time] (in N minutes)" using next_cron_match()
       - If empty: show existing interval display unchanged

    3. In the PROJECT SETTINGS section, add similar schedule display under project config if BACKUP_SCHEDULE is set for the project.

    4. Source scheduling.sh near top of checkpoint.sh (guarded, since status works even without it — just show raw values).
  </action>
  <verify>
    - `bash -n bin/checkpoint.sh` passes
    - `grep -c 'BACKUP_SCHEDULE\|Schedule' bin/checkpoint.sh` returns >= 2
  </verify>
  <done>Checkpoint status shows schedule info when BACKUP_SCHEDULE is configured — displays cron expression, resolved preset name, and next backup time. Falls back to interval display when no schedule set.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/core/config.sh` passes
- [ ] `bash -n bin/backup-daemon.sh` passes
- [ ] `bash -n bin/backup-watcher.sh` passes
- [ ] `bash -n bin/checkpoint.sh` passes
- [ ] `bash -n bin/backup-config.sh` passes
- [ ] `bash tests/unit/test-scheduling.sh` still passes (no regressions)
- [ ] BACKUP_SCHEDULE="" (empty) preserves all existing behavior
- [ ] grep confirms BACKUP_SCHEDULE in all config layers
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No bash syntax errors introduced
- BACKUP_SCHEDULE wired end-to-end across all config layers
- Daemon/watcher respect cron schedule when configured
- Existing BACKUP_INTERVAL behavior unchanged when BACKUP_SCHEDULE is empty
- Status display shows schedule info
</success_criteria>

<output>
After completion, create `.planning/phases/20-cron-style-scheduling/20-02-SUMMARY.md`:

# Phase 20 Plan 2: Config & Integration Summary

**[one-liner]**

## Performance
- Duration, tasks, files

## Accomplishments
- Config wiring
- Daemon/watcher integration
- Status display

## Task Commits
- List of commits

## Files Created/Modified
- [list]

## Decisions Made
[any]

## Issues Encountered
[any]

## Next Step
Phase 20 complete, ready for Phase 21: Storage Usage Warnings
</output>
