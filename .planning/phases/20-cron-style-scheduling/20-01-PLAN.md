---
phase: 20-cron-style-scheduling
plan: 01
type: tdd
---

<objective>
Build a pure-bash cron expression parser and schedule matcher library with comprehensive test coverage.

Purpose: TDD ensures the cron parser handles all standard cron syntax correctly — field parsing, wildcard expansion, step values, ranges, comma-separated lists, DOM/DOW OR logic, named presets, validation, and next-match calculation. Getting this right is critical since incorrect schedule matching causes silent backup failures (too frequent or too rare).
Output: Working, tested `lib/features/scheduling.sh` library with `cron_matches_now()`, `validate_schedule()`, `next_cron_match()`, and preset resolution.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-cron-style-scheduling/20-RESEARCH.md
@tests/test-framework.sh
@tests/unit/test-core-functions.sh

**Tech stack available:** Pure bash, custom test framework (test-framework.sh with test_suite/test_case/test_pass/test_fail/assert_equals)
**Established patterns:** Feature libraries in lib/features/, unit tests in tests/unit/
**Constraining decisions:**
- [Phase 19]: Backup engine is stable, no regressions
- [Research]: Use bitfield array approach for field parsing, DOM/DOW OR logic per POSIX spec, `date +%M %H %d %m %w` with arithmetic leading-zero stripping for cross-platform compat
</context>

<feature>
  <name>Cron expression parsing and schedule matching</name>
  <files>lib/features/scheduling.sh, tests/unit/test-scheduling.sh</files>
  <behavior>
    _parse_cron_field (internal):
      "*", 0, 59 → "0 1 2 3 ... 59"
      "*/15", 0, 59 → "0 15 30 45"
      "5", 0, 59 → "5"
      "1-5", 0, 59 → "1 2 3 4 5"
      "9-17/2", 0, 23 → "9 11 13 15 17"
      "1,3,5", 0, 6 → "1 3 5"
      "1-3,5", 0, 6 → "1 2 3 5"

    _resolve_schedule (presets):
      "@hourly" → "0 * * * *"
      "@workhours" → "*/30 9-17 * * 1-5"
      "@every-5min" → "*/5 * * * *"
      "@daily" → "0 0 * * *"
      "@weekdays" → "0 * * * 1-5"
      "*/5 9-17 * * 1-5" → "*/5 9-17 * * 1-5" (passthrough)

    validate_schedule:
      "*/5 9-17 * * 1-5" → return 0 (valid)
      "@workhours" → return 0 (valid)
      "bad" → return 1 (invalid, only 1 field)
      "99 * * * *" → return 1 (invalid, minute > 59)
      "" → return 1 (invalid, empty)
      "* * * * * *" → return 1 (invalid, 6 fields)

    cron_matches_now (time-injected for testing):
      "* * * * *" matches any time → return 0
      "0 9 * * *" at 09:00 → return 0
      "0 9 * * *" at 10:00 → return 1
      "*/15 * * * *" at :00, :15, :30, :45 → return 0
      "*/15 * * * *" at :07 → return 1
      "* * * * 1-5" on Monday(1) → return 0
      "* * * * 1-5" on Sunday(0) → return 1
      DOM/DOW OR: "* * 15 * 1" on the 15th (any dow) → return 0
      DOM/DOW OR: "* * 15 * 1" on Monday (any dom) → return 0
      DOM/DOW OR: "* * 15 * 1" on Tuesday the 10th → return 1

    next_cron_match (approximate, iterates minutes up to 24h):
      "@hourly" from 09:15 → returns "10:00" (or minutes until)
      "@workhours" from 18:00 Fri → returns next Mon 09:00 (approximate)
  </behavior>
  <implementation>
    Create lib/features/scheduling.sh with these functions:

    1. _parse_cron_field() — Parse single cron field into space-separated integers. Handle *, */N, N, N-M, N-M/S, N,M,O. Support 7=Sunday alias for DOW field.

    2. _field_contains() — Check if integer exists in space-separated list (integer comparison, not string).

    3. _resolve_schedule() — Map @-prefixed presets to 5-field expressions, passthrough raw expressions.

    4. validate_schedule() — Resolve presets, check exactly 5 fields, validate each field's range (min 0-59, hour 0-23, dom 1-31, month 1-12, dow 0-7). Return 0 valid, 1 invalid with error message to stderr.

    5. cron_matches_now() — Accept cron expression + optional override time string for testing. Parse all 5 fields. Check min/hour/month with AND. DOM/DOW: OR when both non-wildcard, AND when either is wildcard (per POSIX). Use `date '+%M %H %d %m %w'` with `$((10#$val))` for zero-stripping.

    6. next_cron_match() — Iterate minute-by-minute from now up to 1440 minutes (24h). Return formatted time string and minutes until next match. Use for status display.

    For testability: cron_matches_now accepts optional second arg for injected time (space-separated: "min hour dom month dow") so tests don't depend on wall clock.
  </implementation>
</feature>

<verification>
bash tests/unit/test-scheduling.sh
All tests pass, covering: field parsing, preset resolution, validation (valid + invalid), time matching (wildcards, steps, ranges, combos, DOM/DOW OR logic), next-match calculation
</verification>

<success_criteria>
- Failing tests written and committed
- Implementation passes all tests
- Refactor complete (if needed)
- All 2-3 commits present
- Library is standalone (sources no other checkpoint libs)
- Cross-platform: uses only POSIX-compatible date formats
</success_criteria>

<output>
After completion, create `.planning/phases/20-cron-style-scheduling/20-01-SUMMARY.md`:

# Phase 20 Plan 1: Scheduling Library (TDD) Summary

**[one-liner]**

## Performance
- Duration, tasks, files

## RED
- What tests written, why they fail

## GREEN
- What implementation made them pass

## REFACTOR
- What cleanup done (if any)

## Task Commits
- List of commits

## Files Created/Modified
- lib/features/scheduling.sh
- tests/unit/test-scheduling.sh

## Issues Encountered
[any]

## Next Step
Ready for 20-02-PLAN.md (config wiring + integration)
</output>
