---
phase: 11-modularize-foundation
plan: 01
type: execute
---

<objective>
Extract core and operations modules from backup-lib.sh into focused files under lib/core/ and lib/ops/.

Purpose: Begin the modularization by extracting the foundational layers (error codes, output, config, file operations, state tracking, initialization) into standalone modules. These are the most fundamental modules — everything else depends on them.
Output: 6 new module files in lib/core/ and lib/ops/, each with include guards and proper headers. backup-lib.sh remains unchanged (still the monolith) — cutover happens in plan 11-03.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-modularize-foundation/11-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/CONCERNS.md
@lib/backup-lib.sh

**Tech stack available:** Pure bash, no new dependencies
**Established patterns:** Include guards (lib/global-status.sh), symlink resolution, `source` with validation
**Constraining decisions:**
- Bash 3.2 minimum (macOS default) — no associative arrays, no ${var,,}
- `set -euo pipefail` only in loader/entry scripts, NOT in individual modules
- Include guard format: `[ -n "$_CHECKPOINT_MODULE_NAME" ] && return || readonly _CHECKPOINT_MODULE_NAME=1`
- Module-level dir: `_CHECKPOINT_LIB_DIR="${_CHECKPOINT_LIB_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/core/ modules — error-codes.sh, output.sh, config.sh</name>
  <files>lib/core/error-codes.sh, lib/core/output.sh, lib/core/config.sh</files>
  <action>
Create `lib/core/` directory. Extract 3 modules from backup-lib.sh:

**lib/core/error-codes.sh** (~120 lines):
- Extract: ERROR CODES AND SUGGESTED FIXES section (lines ~158-274)
- Contains: ERROR_CATALOG array, get_error_description(), get_error_suggestion(), format_error_with_fix(), map_error_to_code()
- Dependencies: None (this is the most foundational module)
- Guard: `_CHECKPOINT_ERROR_CODES`

**lib/core/output.sh** (~100 lines):
- Extract: COLOR OUTPUT section (lines ~1543-1581) + JSON OUTPUT section (lines ~1584-1613) + LOGGING section (lines ~1616-1645)
- Contains: COLOR_* readonly constants, color_echo(), color_red/green/yellow/blue/cyan/gray/bold(), json_escape(), json_kv(), json_kv_num(), json_kv_bool(), backup_log()
- Dependencies: None (standalone output utilities)
- Guard: `_CHECKPOINT_OUTPUT`
- IMPORTANT: The COLOR_* variables use `readonly`. The include guard MUST fire before the readonly declarations on re-source, or you get "readonly variable" errors. The `[ -n "$_CHECKPOINT_OUTPUT" ] && return` pattern handles this correctly — the `return` executes before reaching `readonly` on re-source.
- IMPORTANT: The `backup_log()` function calls `check_drive` which will be in config.sh. This is fine because the loader sources config.sh before any code calls backup_log(). Add a comment: `# @requires: core/config (for check_drive used by backup_log)`

**lib/core/config.sh** (~550 lines):
- Extract: CONFIGURATION LOADING section (lines ~27-43) + DRIVE VERIFICATION section (lines ~45-65) + ALERT CONFIGURATION section (lines ~67-87) + QUIET HOURS section (lines ~88-156) + CONFIGURATION MANAGEMENT section (lines ~2376-2814)
- Contains: load_backup_config(), check_drive(), ALERT_*/NOTIFY_*/QUIET_HOURS default variable declarations, is_quiet_hours(), should_notify(), config_key_to_var(), config_var_to_key(), config_get_schema(), config_validate_value(), config_get_file(), config_get_value(), config_get_all(), config_set_value(), config_create_from_template(), config_validate_file(), config_save_profile(), config_load_profile(), config_list_profiles(), config_audit_log()
- Dependencies: None (config is self-contained)
- Guard: `_CHECKPOINT_CONFIG`
- NOTE: The ALERT_CONFIGURATION and QUIET_HOURS sections contain default variable declarations using `: "${VAR:=default}"` syntax. These are NOT readonly — they're defaults that can be overridden by config files. This is correct and should remain.

Each module gets this header template:
```bash
#!/usr/bin/env bash
# ==============================================================================
# Checkpoint - [Module Name]
# ==============================================================================
# @requires: [dependencies or "none"]
# @provides: [function list]
# ==============================================================================

# Include guard
[ -n "$_CHECKPOINT_MODULE_NAME" ] && return || readonly _CHECKPOINT_MODULE_NAME=1

# Lib directory (set by loader, fallback for standalone sourcing)
_CHECKPOINT_LIB_DIR="${_CHECKPOINT_LIB_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"
```

Copy sections EXACTLY as they exist in backup-lib.sh — same code, same comments, same formatting. Do NOT refactor, rename, or "improve" anything. The goal is a mechanical extraction, not a rewrite.
  </action>
  <verify>
For each module file:
1. `bash -n lib/core/error-codes.sh` — syntax check passes
2. `bash -n lib/core/output.sh` — syntax check passes
3. `bash -n lib/core/config.sh` — syntax check passes
4. Each file starts with include guard pattern
5. Each file has @requires and @provides header comments
  </verify>
  <done>
3 files created in lib/core/. All pass `bash -n` syntax check. Include guards present. Headers complete with @requires/@provides.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lib/ops/ modules — file-ops.sh, state.sh, init.sh</name>
  <files>lib/ops/file-ops.sh, lib/ops/state.sh, lib/ops/init.sh</files>
  <action>
Create `lib/ops/` directory. Extract 3 modules from backup-lib.sh:

**lib/ops/file-ops.sh** (~350 lines):
- Extract: RETRY LOGIC FOR TRANSIENT FAILURES section (lines ~747-833) + FILE LOCKING section (lines ~1092-1164) + HASH-BASED FILE COMPARISON section (lines ~1272-1370) + DISK SPACE ANALYSIS section (lines ~1511-1541)
- Contains: copy_with_retry(), track_file_failure(), acquire_backup_lock(), release_backup_lock(), get_lock_holder_pid(), get_file_hash(), fast_file_compare(), get_disk_usage_pct(), check_disk_space_critical()
- Dependencies: `@requires: core/error-codes (for map_error_to_code), core/output (for color functions)`
- Guard: `_CHECKPOINT_FILE_OPS`
- NOTE: copy_with_retry() sets COPY_FAILURE_REASON global. track_file_failure() uses color functions. Document these cross-module dependencies in header.

**lib/ops/state.sh** (~650 lines):
- Extract: NOTIFICATION SYSTEM section (lines ~276-439) + BACKUP STATE TRACKING (JSON) section (lines ~441-745) + FAILURE REPORTING section (lines ~959-1091)
- Contains: send_notification(), send_backup_failure_notification(), send_backup_success_notification(), send_backup_warning_notification(), init_backup_state(), add_file_failure(), add_database_failure(), calculate_severity(), needs_immediate_action(), get_severity_reason(), write_backup_state(), read_backup_state(), display_backup_failures()
- Dependencies: `@requires: core/error-codes (for get_error_description, get_error_suggestion, format_error_with_fix), core/output (for color functions, json helpers), core/config (for NOTIFY_*, QUIET_HOURS settings, should_notify)`
- Guard: `_CHECKPOINT_STATE`
- NOTE: This module has the most cross-dependencies. The notification functions read ALERT_*, NOTIFY_*, QUIET_HOURS_* variables (set in config.sh defaults). The state tracking functions use JSON helpers from output.sh.

**lib/ops/init.sh** (~30 lines):
- Extract: INITIALIZATION section (lines ~1647-1674)
- Contains: init_state_dirs(), init_backup_dirs()
- Dependencies: `@requires: core/config (for check_drive)`
- Guard: `_CHECKPOINT_INIT`
- NOTE: Small but separate because initialization is a distinct concern. init_backup_dirs() calls check_drive().

Same extraction rules: Copy code exactly. Add module headers with include guard, @requires, @provides. Do NOT refactor.
  </action>
  <verify>
For each module file:
1. `bash -n lib/ops/file-ops.sh` — syntax check passes
2. `bash -n lib/ops/state.sh` — syntax check passes
3. `bash -n lib/ops/init.sh` — syntax check passes
4. Each file starts with include guard pattern
5. Each file has @requires and @provides header comments
  </verify>
  <done>
3 files created in lib/ops/. All pass `bash -n` syntax check. Include guards present. Headers complete with @requires/@provides.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `lib/core/` directory exists with 3 files
- [ ] `lib/ops/` directory exists with 3 files
- [ ] All 6 files pass `bash -n` syntax check
- [ ] All 6 files have include guard as first executable line
- [ ] All 6 files have @requires/@provides documentation
- [ ] backup-lib.sh is UNCHANGED (still the monolith — cutover is plan 11-03)
- [ ] No functions were accidentally omitted (spot-check: grep for key function names in new files)
</verification>

<success_criteria>

- 6 module files created (3 core, 3 ops)
- All pass syntax validation
- All have proper include guards and headers
- backup-lib.sh unchanged
- Functions extracted match the section mappings from 11-RESEARCH.md
</success_criteria>

<output>
After completion, create `.planning/phases/11-modularize-foundation/11-01-SUMMARY.md`
</output>
