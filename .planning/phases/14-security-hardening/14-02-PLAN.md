---
phase: 14-security-hardening
plan: 02
type: execute
---

<objective>
Create platform-aware credential provider abstraction for secure database credential storage.

Purpose: Replace plaintext credential handling with OS-native secret stores (macOS Keychain, Linux secret-tool/pass) with env var fallback — so database passwords aren't stored in cleartext config files.
Output: New `lib/security/credential-provider.sh` module + credential integration in database backup flow.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research findings:
@.planning/phases/14-security-hardening/14-RESEARCH.md

# Prior plan in this phase:
@.planning/phases/14-security-hardening/14-01-SUMMARY.md

# Key source files:
@lib/database-detector.sh
@lib/backup-lib.sh
@lib/core/config.sh
@templates/backup-config.sh

**Tech stack available:** modular bash library, include guards, platform detection (uname -s)
**Established patterns:** include-guard-pattern, module-header-template, platform/ directory for platform-specific code
**Constraining decisions:**
- Research: Opt-in credential storage (interactive prompt during setup, env var fallback for non-interactive/daemon)
- Research: macOS `security` CLI for Keychain, Linux `secret-tool` for GNOME Keyring, `pass` as alternative
- Research: Pre-authorize during install with `-T` flag to avoid daemon Keychain prompts
- Research: MYSQL_PWD env var pattern already correct (ps-safe) — don't change
- Pitfall: Keychain access prompts can block daemon — must pre-authorize or fall through to env var
- Pitfall: Linux server with no desktop has no secret-tool — env var fallback must always work
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/security/credential-provider.sh module</name>
  <files>lib/security/credential-provider.sh</files>
  <action>
Create credential provider module with platform detection and fallback chain. Follow established module patterns (include guard, module header).

Functions to implement:

1. `_detect_credential_backend()` — Internal. Detect available credential store.
   - macOS (Darwin): Check for `security` command → return "keychain"
   - Linux: Check for `secret-tool` → return "secret-tool"; else check for `pass` → return "pass"
   - Fallback: return "env" (always available)
   - Cache result in `_CHECKPOINT_CRED_BACKEND` variable for session

2. `credential_store()` — Store a credential in the best available backend.
   Args: $1=service (e.g., "checkpoint-db"), $2=account (e.g., "postgres-myapp"), $3=password
   - keychain: `security add-generic-password -s "$service" -a "$account" -w "$password" -U`
   - secret-tool: `echo -n "$password" | secret-tool store --label="Checkpoint: $account" service "$service" account "$account"`
   - pass: `echo -n "$password" | pass insert -f "checkpoint/${service}/${account}"`
   - env: Print instruction to user: "Set environment variable CHECKPOINT_${SERVICE}_${ACCOUNT}=${password}" (uppercase, hyphens→underscores)
   - Return 0 on success, 1 on failure with error message

3. `credential_get()` — Retrieve a credential from the best available backend.
   Args: $1=service, $2=account
   - keychain: `security find-generic-password -s "$service" -a "$account" -w 2>/dev/null`
   - secret-tool: `secret-tool lookup service "$service" account "$account" 2>/dev/null`
   - pass: `pass show "checkpoint/${service}/${account}" 2>/dev/null`
   - env: Construct var name `CHECKPOINT_${SERVICE}_${ACCOUNT}` (uppercase, hyphens→underscores), return `${!var_name:-}`
   - Output password to stdout (empty string if not found)
   - Return 0 if found, 1 if not found

4. `credential_delete()` — Remove a credential from the backend.
   Args: $1=service, $2=account
   - keychain: `security delete-generic-password -s "$service" -a "$account" 2>/dev/null`
   - secret-tool: `secret-tool clear service "$service" account "$account" 2>/dev/null`
   - pass: `pass rm -f "checkpoint/${service}/${account}" 2>/dev/null`
   - env: Print instruction to unset the variable
   - Return 0

5. `credential_backend_name()` — Return human-readable name of current backend for UI display.
   - "macOS Keychain", "GNOME Keyring (secret-tool)", "pass (GPG)", "Environment variables"

Include module header:
```
# @requires: none (standalone security module)
# @provides: credential_store, credential_get, credential_delete, credential_backend_name
```

Do NOT add to backup-lib.sh loader — standalone module sourced on-demand.

IMPORTANT: All functions must handle the case where the backend tool exists but fails (e.g., keychain locked, pass not initialized). On failure, log a warning and fall through to env var backend rather than erroring out. The credential provider should NEVER block a backup from running.
  </action>
  <verify>
    - File exists at lib/security/credential-provider.sh
    - bash -n lib/security/credential-provider.sh passes
    - Module has include guard
    - On macOS: `source lib/security/credential-provider.sh && credential_backend_name` outputs "macOS Keychain"
  </verify>
  <done>lib/security/credential-provider.sh exists with 5 functions, passes syntax check, include guard present, backend detection works on current platform</done>
</task>

<task type="auto">
  <name>Task 2: Integrate credential provider into database backup flow</name>
  <files>lib/database-detector.sh, templates/backup-config.sh</files>
  <action>
Add optional credential provider integration to database-detector.sh's backup functions. This is opt-in — existing env file / URL-based credential flow continues to work unchanged.

**lib/database-detector.sh changes:**

1. Add a helper function `_get_db_credential()` near the top (after the existing include guard):
   - Args: $1=db_type (postgres/mysql/mongodb), $2=database_name
   - If `CHECKPOINT_USE_CREDENTIAL_STORE` is set to "true" (from config):
     - Source credential-provider.sh if not already sourced
     - Try `credential_get "checkpoint-db" "${db_type}-${database_name}"`
     - If found, return password on stdout
   - If not configured or not found, return empty string (existing flow handles this)

2. In the PostgreSQL backup section (~line 555 area, where `password` is extracted from the pipe-delimited connection string):
   - After extracting password from connection string, if password is empty:
     - Try `_get_db_credential "postgres" "$database"`
     - If found, use that password

3. Same pattern for MySQL backup section (~line 719 area):
   - After extracting password, if empty, try `_get_db_credential "mysql" "$database"`

4. Same pattern for MongoDB backup section (~line 857 area):
   - After extracting password, if empty, try `_get_db_credential "mongodb" "$database"`

**templates/backup-config.sh changes:**

Add a new section after the database settings section:
```bash
# ── Credential Storage ─────────────────────────────
# Use OS-native credential store for database passwords
# Options: true/false (default: false)
# When true, Checkpoint checks macOS Keychain / Linux secret-tool / pass
# before falling back to .env file passwords
# Store credentials: checkpoint credential store <db-type> <db-name>
CHECKPOINT_USE_CREDENTIAL_STORE="false"
```

IMPORTANT: This is additive and opt-in. Existing password extraction from .env files and connection URLs is NOT changed. The credential store is only checked when the extracted password is empty AND the config flag is enabled. This ensures zero disruption to existing users.
  </action>
  <verify>
    - bash -n lib/database-detector.sh passes
    - bash -n templates/backup-config.sh passes (source it in subshell)
    - grep "CHECKPOINT_USE_CREDENTIAL_STORE" templates/backup-config.sh shows the new config option
    - grep "_get_db_credential" lib/database-detector.sh shows the integration points
  </verify>
  <done>Credential provider optionally integrated into database backup flow. Config template has CHECKPOINT_USE_CREDENTIAL_STORE option. All files pass syntax check. Existing password flow unchanged when feature is disabled.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/security/credential-provider.sh` passes
- [ ] `bash -n lib/database-detector.sh` passes
- [ ] `bash -n templates/backup-config.sh` passes
- [ ] `credential_backend_name` returns correct platform name
- [ ] `grep "CHECKPOINT_USE_CREDENTIAL_STORE" templates/backup-config.sh` shows default "false"
- [ ] Database backup still works without credential store enabled (no regressions)
</verification>

<success_criteria>

- lib/security/credential-provider.sh created with platform-aware credential abstraction
- macOS Keychain, Linux secret-tool, Linux pass, and env var backends supported
- Credential provider integrated into database-detector.sh as opt-in fallback
- Config template updated with CHECKPOINT_USE_CREDENTIAL_STORE option
- Existing password extraction flow unchanged (zero disruption)
- All files pass bash syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/14-security-hardening/14-02-SUMMARY.md`
</output>
