---
phase: 14-security-hardening
plan: 03
type: execute
---

<objective>
Add SHA256 integrity verification to self-update mechanism and update security-related messaging across install scripts.

Purpose: Close the remaining security gap â€” backup-update.sh downloads a tar.gz from GitHub and extracts it with zero integrity verification, making it vulnerable to tampering. Also standardize security messaging in install/setup flows.
Output: Verified self-update flow + updated install messaging. Phase 14 complete.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research findings:
@.planning/phases/14-security-hardening/14-RESEARCH.md

# Prior plans in this phase:
@.planning/phases/14-security-hardening/14-01-SUMMARY.md
@.planning/phases/14-security-hardening/14-02-SUMMARY.md

# Key source files:
@bin/backup-update.sh
@bin/install.sh
@lib/security/secure-download.sh

**Tech stack available:** lib/security/secure-download.sh (from Plan 01) with compute_sha256, download_and_verify, download_with_checksums
**Constraining decisions:**
- Research: Use deterministic GitHub release asset URL pattern: `releases/download/vX.Y.Z/SHA256SUMS`
- Research: If SHA256SUMS not available (private repo), warn but allow update (don't block)
- Research: Use existing secure-download.sh module for SHA256 computation
- Pitfall: GitHub API rate limits â€” use release asset URLs, not API endpoints
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SHA256 verification to backup-update.sh</name>
  <files>bin/backup-update.sh</files>
  <action>
Modify the download section of backup-update.sh (~lines 159-176) to verify the downloaded tar.gz against a published SHA256SUMS file.

Changes:

1. After the temp dir creation and before/during the download, source secure-download.sh:
   ```
   source "$LIB_DIR/security/secure-download.sh"
   ```

2. Replace the current download block (lines 165-176):
   - Construct URLs:
     - `download_url="https://github.com/nizernoj/Checkpoint/archive/refs/tags/v${LATEST_VERSION}.tar.gz"`
     - `checksums_url="https://github.com/nizernoj/Checkpoint/releases/download/v${LATEST_VERSION}/SHA256SUMS"`
   - Try verified download first:
     - Download SHA256SUMS with `curl -fsSL "$checksums_url" -o "$TEMP_DIR/SHA256SUMS" 2>/dev/null`
     - If SHA256SUMS available:
       - Download tar.gz
       - Compute SHA256 via `compute_sha256 "$TEMP_DIR/checkpoint.tar.gz"`
       - Extract expected hash from SHA256SUMS (grep for the tar.gz filename)
       - Compare hashes
       - On mismatch: print "SECURITY: Download integrity check failed", print expected/actual, exit 1
       - On match: print "âœ“ Integrity verified (SHA256)" and continue
     - If SHA256SUMS NOT available (404 or fetch fails):
       - Print "âš   No checksum available for v${LATEST_VERSION} â€” skipping integrity verification"
       - Download tar.gz normally and continue (don't block private repos or older releases without checksums)

3. Keep the existing extract and install logic unchanged (lines 174+).

4. The tar.gz filename in the SHA256SUMS file will be `checkpoint-v${LATEST_VERSION}.tar.gz` or similar â€” use a flexible grep pattern that matches the version number.

IMPORTANT: The GitHub archive URL produces a file named `Checkpoint-${LATEST_VERSION}.tar.gz` when downloaded. The SHA256SUMS file (a release asset we'll publish) should reference this filename. Since we control the SHA256SUMS content, match whatever filename we use in the grep. For now, grep for any line containing `.tar.gz` in the checksums file (there should only be one).

Do NOT change the existing private repo handling logic â€” if the repo is private and the download fails, the existing "show manual instructions" flow still works.
  </action>
  <verify>
    - bash -n bin/backup-update.sh passes
    - grep "compute_sha256\|SHA256\|integrity" bin/backup-update.sh shows the verification code
    - grep "secure-download.sh" bin/backup-update.sh shows the source statement
    - The existing flow for private repos (manual instructions) is preserved
  </verify>
  <done>backup-update.sh verifies SHA256 when checksums available, warns and continues when not available. Passes syntax check. Private repo flow unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Update install scripts with security messaging and direnv reference</name>
  <files>bin/install.sh, integrations/direnv/install-direnv.sh</files>
  <action>
Minor security messaging updates across install-related scripts.

**bin/install.sh:**
- Find the section that shows post-install information/summary
- Add a brief security note to the install success output:
  ```
  echo "ðŸ”’ Security: Downloads are SHA256-verified, credentials use OS keychain"
  ```
  Place this in the final success summary section, after the existing completion messages.

**integrations/direnv/install-direnv.sh (line 31):**
- This file has the last remaining `curl|bash` reference (an echo suggestion for direnv install)
- Change the message from:
  `echo "  Generic: curl -sfL https://direnv.net/install.sh | bash"`
  to:
  `echo "  Generic: See https://direnv.net/docs/installation.html"`
- This is just a help message (not executed code), but updating it removes the last curl|bash reference from the codebase

After these changes, do a final sweep:
- `grep -r 'curl.*|.*bash' lib/ bin/ integrations/` should return ZERO results
- If any remain that are actual code (not comments), address them

**Phase 14 completion verification:**
Run a final codebase security check:
1. No `curl|bash` patterns remain (except comments if any)
2. lib/security/ has both modules (secure-download.sh, credential-provider.sh)
3. All modified files pass syntax check
  </action>
  <verify>
    - bash -n bin/install.sh passes
    - bash -n integrations/direnv/install-direnv.sh passes
    - `grep -r 'curl.*|.*bash' lib/ bin/ integrations/` returns zero results (no curl|bash anywhere)
    - `ls lib/security/` shows secure-download.sh and credential-provider.sh
  </verify>
  <done>All install scripts updated with security messaging. Zero curl|bash patterns remain in entire codebase. Both security modules exist. Phase 14 complete.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `bash -n bin/backup-update.sh` passes
- [ ] `bash -n bin/install.sh` passes
- [ ] `bash -n integrations/direnv/install-direnv.sh` passes
- [ ] `grep -r 'curl.*|.*bash' lib/ bin/ integrations/` returns zero results
- [ ] `ls lib/security/` shows both modules
- [ ] Self-update has SHA256 verification code path
- [ ] Credential provider has platform detection and fallback chain
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Self-update verifies SHA256 when checksums available
- Self-update gracefully skips verification when checksums unavailable
- No curl|bash patterns remain anywhere in codebase
- Both security modules exist and pass syntax checks
- Phase 14: Security Hardening complete
</success_criteria>

<output>
After completion, create `.planning/phases/14-security-hardening/14-03-SUMMARY.md` with phase completion note:

# Phase 14 Plan 03: Self-Update Integrity + Messaging Summary

**[one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered

## Phase 14 Complete

All 3 plans finished:
1. **14-01:** Secure download library + rclone migration
2. **14-02:** Credential provider abstraction + database integration
3. **14-03:** Self-update integrity + install messaging

## Next Phase Readiness
- Phase 14 complete, ready for Phase 15: Linux Systemd Support
- No blockers or concerns
</output>
