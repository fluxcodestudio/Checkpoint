---
phase: 23-encryption-at-rest
plan: 01
type: execute
---

<objective>
Create the encryption foundation: library module with encrypt/decrypt functions, config integration, and CLI key management.

Purpose: Establish all encryption primitives and configuration that Plans 02 and 03 depend on.
Output: Working encryption library, config vars wired, `checkpoint encrypt` CLI command for key generation and status.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-encryption-at-rest/23-RESEARCH.md

# Key source files:
@lib/core/config.sh
@lib/features/storage-monitor.sh
@lib/features/verification.sh
@bin/checkpoint.sh
@bin/bootstrap.sh
@templates/backup-config.sh

**Established patterns:**
- Feature libraries go in `lib/features/` with include guard pattern (`_CHECKPOINT_MODNAME`)
- Config defaults use `: "${VAR:=default}"` in lib/core/config.sh
- Config key mapping in `config_key_to_var()` and `config_var_to_key()` case statements
- Config template vars in `templates/backup-config.sh`
- CLI subcommands routed via case statement in `bin/checkpoint.sh`
- Standalone CLI scripts use `source "$(dirname "${BASH_SOURCE[0]}")/bootstrap.sh"` pattern
- All scripts use `set -euo pipefail`, 4-space indent, `local` for all function vars

**From RESEARCH.md (don't hand-roll):**
- Use `age` CLI for encryption (not openssl enc or custom crypto)
- Use `age-keygen` for key generation (not custom key derivation)
- Use age stdin/stdout pipes for streaming (not read-encrypt-write loops)

**Constraining decisions:**
- Bash 3.2+ compatibility (no associative arrays)
- macOS primary platform (brew install age)
- Compress-then-encrypt order (never encrypt-then-compress)
- Cloud-only encryption (local backups stay unencrypted)
- Key-based encryption (not passphrase — must work unattended)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/features/encryption.sh library module</name>
  <files>lib/features/encryption.sh</files>
  <action>
Create encryption library with include guard pattern matching other lib/features/ modules.

Functions to implement:
- `check_age_installed()` — Check if `age` command exists, return 1 with install instructions if not
- `encryption_enabled()` — Return 0 if ENCRYPTION_ENABLED=true AND age is installed AND key file exists
- `get_age_recipient()` — Extract public key from private key file via `age-keygen -y "$ENCRYPTION_KEY_PATH"`, cache in variable to avoid repeated subprocess calls
- `encrypt_file()` — Args: $1=source_path, $2=dest_path (should end in .age). Use `age -r "$recipient" "$src" -o "$dest"`. Return 1 on failure with stderr message.
- `decrypt_file()` — Args: $1=encrypted_path (.age file), $2=dest_path. Use `age -d -i "$ENCRYPTION_KEY_PATH" "$src" -o "$dest"`. Return 1 on failure.
- `encrypt_stream()` — Read stdin, write encrypted to stdout. For piping: `age -r "$recipient"`. Used for database pipeline `gzip | encrypt_stream > file.db.gz.age`
- `decrypt_stream()` — Read stdin, write decrypted to stdout. `age -d -i "$ENCRYPTION_KEY_PATH"`. Used for restore pipeline.
- `generate_encryption_key()` — Run `age-keygen -o "$ENCRYPTION_KEY_PATH"`, chmod 600, extract and display public key. Warn about key backup importance. Return 1 if key already exists (require --force to overwrite).
- `show_encryption_status()` — Display: enabled/disabled, age installed, key exists, key path, public key (first 20 chars + ...)

Header format: standard Checkpoint module header with @requires and @provides.
Module sets `log_set_context "encryption"` after include guard.
Use `_CHECKPOINT_LIB_DIR` for path references. Default key path: `$HOME/.config/checkpoint/age-key.txt`.
  </action>
  <verify>
source lib/features/encryption.sh succeeds without errors (functions defined, no execution side effects).
Run: `bash -n lib/features/encryption.sh` — syntax check passes.
  </verify>
  <done>Library module exists with all 9 functions, include guard, standard header, bash -n passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire encryption config into config.sh and template</name>
  <files>lib/core/config.sh, templates/backup-config.sh</files>
  <action>
In lib/core/config.sh:

1. Add encryption defaults after the storage monitoring section (~line 191), before the per-project notification override section:
```
# Encryption at rest (cloud backups only)
: "${ENCRYPTION_ENABLED:=false}"          # Enable encryption for cloud-destined backups
: "${ENCRYPTION_KEY_PATH:=$HOME/.config/checkpoint/age-key.txt}"  # Path to age private key
```

2. Add to `config_key_to_var()` case statement (after the storage.* entries):
```
"encryption.enabled") echo "ENCRYPTION_ENABLED" ;;
"encryption.key_path") echo "ENCRYPTION_KEY_PATH" ;;
```

3. Add to `config_var_to_key()` case statement (after the STORAGE_* entries):
```
"ENCRYPTION_ENABLED") echo "encryption.enabled" ;;
"ENCRYPTION_KEY_PATH") echo "encryption.key_path" ;;
```

4. Add to `apply_global_defaults()` case statement (after STORAGE entries):
```
DEFAULT_ENCRYPTION_ENABLED) : "${ENCRYPTION_ENABLED:=$value}" ;;
DEFAULT_ENCRYPTION_KEY_PATH) : "${ENCRYPTION_KEY_PATH:=$value}" ;;
```

In templates/backup-config.sh:

Add after the STORAGE_CLEANUP_SUGGEST entry, with section comment:
```
# --- Encryption at Rest ---
# Encrypt cloud-destined backups using age (https://github.com/FiloSottile/age)
# Local backups remain unencrypted for fast access
# Run: checkpoint encrypt setup — to generate encryption key
ENCRYPTION_ENABLED=false
# ENCRYPTION_KEY_PATH="$HOME/.config/checkpoint/age-key.txt"
```
  </action>
  <verify>
bash -n lib/core/config.sh — syntax check passes.
grep ENCRYPTION lib/core/config.sh — shows defaults and mappings.
grep ENCRYPTION templates/backup-config.sh — shows template entries.
  </verify>
  <done>ENCRYPTION_ENABLED and ENCRYPTION_KEY_PATH wired into config defaults, key-to-var mappings, var-to-key mappings, global defaults, and config template.</done>
</task>

<task type="auto">
  <name>Task 3: Add checkpoint encrypt CLI subcommand</name>
  <files>bin/checkpoint-encrypt.sh, bin/checkpoint.sh</files>
  <action>
Create bin/checkpoint-encrypt.sh:
- Use bootstrap.sh sourcing pattern (same as checkpoint-diff.sh)
- Modes: `setup` (generate key), `status` (show encryption state), `test` (encrypt/decrypt a test string to verify working)
- `setup` mode: Call `generate_encryption_key()` from encryption library. On success, show public key, remind to backup key, suggest adding ENCRYPTION_ENABLED=true to config.
- `status` mode: Call `show_encryption_status()` from encryption library.
- `test` mode: Create temp file, encrypt it, decrypt it, compare — confirm round-trip works. Clean up temp files.
- Standard --help/-h support with usage examples.
- Default mode (no args): show status.

Wire into bin/checkpoint.sh:
- Add `encrypt|--encrypt` case to the main routing case statement, dispatching to `bin/checkpoint-encrypt.sh "$@"`
- Add to --help output in the commands list: `  encrypt          Manage backup encryption (setup, status, test)`
  </action>
  <verify>
bash -n bin/checkpoint-encrypt.sh — syntax check passes.
bin/checkpoint-encrypt.sh --help — shows usage.
grep "encrypt" bin/checkpoint.sh — shows routing entry.
  </verify>
  <done>checkpoint encrypt command works with setup/status/test modes. Routed from checkpoint.sh.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/features/encryption.sh` passes
- [ ] `bash -n lib/core/config.sh` passes
- [ ] `bash -n bin/checkpoint-encrypt.sh` passes
- [ ] `bash -n bin/checkpoint.sh` passes
- [ ] `grep -c ENCRYPTION lib/core/config.sh` returns 6+ (defaults + mappings)
- [ ] `bin/checkpoint-encrypt.sh --help` displays usage
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No syntax errors in any modified files
- Encryption library provides all primitives needed by Plans 02 and 03
- Config vars wired with proper defaults
- CLI key management accessible via `checkpoint encrypt`
</success_criteria>

<output>
After completion, create `.planning/phases/23-encryption-at-rest/23-01-SUMMARY.md`
</output>
