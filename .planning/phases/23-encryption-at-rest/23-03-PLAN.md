---
phase: 23-encryption-at-rest
plan: 03
type: execute
---

<objective>
Adapt restore, discovery, verification, and diff to handle encrypted (.age) files transparently.

Purpose: All consumer-side operations work correctly with both encrypted and unencrypted backup files.
Output: Modified restore, discovery, verification, and diff modules that handle .age extension.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-encryption-at-rest/23-RESEARCH.md
@.planning/phases/23-encryption-at-rest/23-01-SUMMARY.md
@.planning/phases/23-encryption-at-rest/23-02-SUMMARY.md

# Key source files:
@lib/features/restore.sh
@lib/features/backup-discovery.sh
@lib/features/verification.sh
@bin/checkpoint-diff.sh
@lib/features/encryption.sh

**From RESEARCH.md pitfalls:**
- Pitfall 4: Encrypted files break verification — verify BEFORE encryption (local copy) or decrypt-then-verify
- Pitfall 5: .age extension breaks discovery patterns — update pattern matching for .db.gz.age and .timestamp.age
- Restore must detect .age files and decrypt before gunzip/copy

**Key patterns:**
- Database backups: `*.db.gz` (unencrypted) or `*.db.gz.age` (encrypted)
- Archived files: `filename.YYYYMMDD_HHMMSS` (unencrypted) or `filename.YYYYMMDD_HHMMSS.age` (encrypted)
- Discovery uses find/glob patterns to locate backup files
- Verification runs SQLite PRAGMA checks on .db.gz files
- Diff compares file lists between snapshots
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update restore.sh to handle encrypted backups</name>
  <files>lib/features/restore.sh</files>
  <action>
Modify restore functions to transparently handle .age files:

1. In `restore_database_from_backup()`:
- Before the existing gunzip/restore logic, check if the backup file ends in `.age`
- If encrypted: decrypt to temp file first using `decrypt_file()` from encryption library, then proceed with normal gunzip restore from the decrypted temp file, clean up temp file after
- If not encrypted: proceed with existing logic unchanged
- Pattern:
```bash
local actual_backup="$backup_file"
if [[ "$backup_file" == *.age ]]; then
    if ! command -v age >/dev/null 2>&1; then
        log_error "Cannot restore encrypted backup: age not installed"
        return 1
    fi
    actual_backup="${backup_file%.age}.tmp-decrypt"
    if ! decrypt_file "$backup_file" "$actual_backup"; then
        log_error "Decryption failed for: $backup_file"
        rm -f "$actual_backup"
        return 1
    fi
    # Clean up decrypted temp file on function exit
fi
```

2. In `restore_file_from_backup()`:
- Same pattern: if file ends in .age, decrypt to temp first, then copy to destination, clean up temp
- Handle both `filename.YYYYMMDD_HHMMSS.age` (archived) and `filename.age` (current) patterns

3. Source encryption library conditionally at module level (after include guard):
```bash
if [ -f "$_CHECKPOINT_LIB_DIR/features/encryption.sh" ]; then
    source "$_CHECKPOINT_LIB_DIR/features/encryption.sh"
fi
```
  </action>
  <verify>
bash -n lib/features/restore.sh — syntax check passes.
grep -c "\.age\|decrypt" lib/features/restore.sh — shows .age handling (expect 5+).
  </verify>
  <done>Restore operations transparently handle both encrypted (.age) and unencrypted backup files. Decryption happens automatically when age key is available.</done>
</task>

<task type="auto">
  <name>Task 2: Update discovery, verification, and diff for .age extension</name>
  <files>lib/features/backup-discovery.sh, lib/features/verification.sh, bin/checkpoint-diff.sh</files>
  <action>
1. In lib/features/backup-discovery.sh:
- Find where database backup patterns are matched (look for `*.db.gz` or find commands for database files)
- Add `.db.gz.age` as an additional pattern alongside `.db.gz`
- Find where archived file patterns are matched (look for timestamp suffix patterns like `*.YYYYMMDD_*`)
- Add `.age` suffix awareness: when listing file versions, strip `.age` before extracting timestamp, then note file is encrypted
- When returning file lists, include both encrypted and unencrypted versions

2. In lib/features/verification.sh:
- Find where SQLite PRAGMA integrity checks run on .db.gz files
- Add handling: if file ends in `.db.gz.age`, either:
  a) Skip with informational message "Encrypted backup — verify local copy instead", OR
  b) If encryption library available: decrypt to temp, verify, clean up temp
- Prefer option (a) for simplicity since local unencrypted copies exist and are already verified
- Add a note in verification output when encrypted files are detected but skipped

3. In bin/checkpoint-diff.sh:
- Find where snapshot files are discovered (discover_snapshots or similar function)
- Update patterns to also match `.age` suffixed files
- When displaying file names in diff output, strip `.age` suffix for clean display but note encryption status
- In the `extract_timestamp()` function: handle `filename.YYYYMMDD_HHMMSS.age` by stripping .age before extracting timestamp
  </action>
  <verify>
bash -n lib/features/backup-discovery.sh — syntax check passes.
bash -n lib/features/verification.sh — syntax check passes.
bash -n bin/checkpoint-diff.sh — syntax check passes.
grep -c "\.age" lib/features/backup-discovery.sh lib/features/verification.sh bin/checkpoint-diff.sh — shows .age handling in all three files.
  </verify>
  <done>Discovery finds both encrypted and unencrypted backups. Verification handles encrypted files gracefully. Diff recognizes .age extension and extracts timestamps correctly.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/features/restore.sh` passes
- [ ] `bash -n lib/features/backup-discovery.sh` passes
- [ ] `bash -n lib/features/verification.sh` passes
- [ ] `bash -n bin/checkpoint-diff.sh` passes
- [ ] All four files handle .age extension
- [ ] Restore decrypts before restoring
- [ ] Verification gracefully handles encrypted files
- [ ] Discovery finds both .db.gz and .db.gz.age files
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No syntax errors in any modified files
- Encrypted backups discoverable, verifiable (gracefully), restorable, and diffable
- Phase 23 complete — encryption at rest fully integrated
</success_criteria>

<output>
After completion, create `.planning/phases/23-encryption-at-rest/23-03-SUMMARY.md`:

# Phase 23 Plan 03: Restore & Discovery Adaptation Summary

**[Substantive one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Phase Readiness
</output>
