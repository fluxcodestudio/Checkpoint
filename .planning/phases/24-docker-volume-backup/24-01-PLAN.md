---
phase: 24-docker-volume-backup
plan: 01
type: execute
---

<objective>
Create Docker volume backup library with detection, export, and restore capabilities.

Purpose: Provide the core engine for discovering Docker Compose volumes, safely exporting them via temporary busybox containers, and restoring from archives — following established feature module patterns.
Output: lib/features/docker-volumes.sh with full detection, backup, and restore functions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-docker-volume-backup/24-RESEARCH.md

# Key source files (established patterns to follow):
@lib/features/encryption.sh
@lib/database-detector.sh
@lib/features/backup-discovery.sh

**Tech stack available:** Docker CLI 24.x+, Docker Compose v2, busybox, tar/gzip, age encryption (existing)
**Established patterns:** Feature module include guard, log_set_context, conditional sourcing, Docker lifecycle (is_docker_running/start_docker/stop_docker), container-aware stop/start
**Constraining decisions:**
- Phase 23: Encryption pipeline produces .age files — volume backups should encrypt if ENCRYPTION_ENABLED=true
- Pure bash, Bash 3.2+ compatible (no associative arrays, no ${var,,})
- Docker volumes only accessible via `docker run` (not filesystem) on macOS Docker Desktop
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-volumes.sh feature library</name>
  <files>lib/features/docker-volumes.sh</files>
  <action>
Create lib/features/docker-volumes.sh following the encryption.sh module pattern:

**Module boilerplate:**
- Include guard: `[ -n "${_CHECKPOINT_DOCKER_VOLUMES:-}" ] && return || readonly _CHECKPOINT_DOCKER_VOLUMES=1`
- Lib dir: `_CHECKPOINT_LIB_DIR="${_CHECKPOINT_LIB_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"`
- Log context: `log_set_context "docker-volumes"`

**Core functions:**

1. `docker_volumes_enabled()` — Check `${BACKUP_DOCKER_VOLUMES:-false}` == "true"

2. `detect_compose_file()` — Takes $1=project_dir. Check compose.yaml, compose.yml, docker-compose.yaml, docker-compose.yml in priority order. Echo filename, return 0/1.

3. `discover_project_volumes()` — Takes $1=project_dir. Check Docker available (reuse `is_docker_running` from database-detector.sh if sourced, else inline check with `timeout 5 docker info`). Check Compose v2 (`docker compose version`) then v1 fallback (`docker-compose version`). Run `$compose_cmd config --volumes` in project dir. Return volume names one per line. Do NOT parse YAML with grep/sed (research: don't hand-roll).

4. `filter_volumes()` — Takes volume list on stdin. Apply DOCKER_VOLUME_INCLUDES (if set, only backup listed volumes) and DOCKER_VOLUME_EXCLUDES (skip matching patterns). Use simple glob matching with case statement. Output filtered list.

5. `backup_single_volume()` — Takes $1=volume_name, $2=backup_dir. Create backup at `$backup_dir/docker-volumes/${volume_name}.tar.gz`. Use the standard busybox tar pattern from research:
   ```
   docker run --rm -v "${volume_name}:/data:ro" -v "$host_backup_dir:/backup" busybox tar czf "/backup/${volume_name}.tar.gz" -C /data .
   ```
   CRITICAL: Use `-C /data .` (not bare `/data`) to avoid nested directory structures on restore.
   If encryption_enabled (check if function exists + returns 0), encrypt the .tar.gz to .tar.gz.age and remove the unencrypted file.

6. `backup_volume_safely()` — Takes $1=volume_name, $2=backup_dir. Find containers using volume: `docker ps --filter "volume=${volume_name}" --format "{{.Names}}"`. Stop each, backup, restart. Track stopped containers in local array. Always restart in finally-style cleanup (even on backup failure). Log each stop/start.

7. `backup_docker_volumes()` — Main entry. Takes $1=project_dir, $2=backup_dir. Check enabled, detect compose file, discover volumes, filter, create `$backup_dir/docker-volumes/` dir, iterate and call backup_volume_safely for each. Return 0 if all succeed, 1 if any fail. Log summary (N volumes backed up, N skipped, N failed).

8. `restore_single_volume()` — Takes $1=volume_name, $2=backup_file. Create volume if not exists (`docker volume create`). If backup_file ends in .age, decrypt to temp file first. Clear existing data (`docker run --rm busybox sh -c "rm -rf /data/* /data/.[!.]* /data/..?*"`). Extract: `docker run --rm busybox tar xzf ... -C /data`. Clean up temp decrypt file if used.

9. `list_volume_backups()` — Takes $1=backup_dir. List files in `$backup_dir/docker-volumes/`. Show volume name, size, date for each .tar.gz or .tar.gz.age file.

**Important conventions:**
- All local variables with `local` keyword
- Quote all variable expansions
- Use `$((var + 1))` not `((var++))`
- Errors to stderr, respect log functions
- Standard file header with description block
  </action>
  <verify>bash -n lib/features/docker-volumes.sh (syntax check passes); grep -c "^[a-z_]*() {" lib/features/docker-volumes.sh shows 9+ functions defined; grep "_CHECKPOINT_DOCKER_VOLUMES" confirms include guard</verify>
  <done>docker-volumes.sh exists with include guard, all 9 functions defined, bash -n passes, follows encryption.sh module pattern</done>
</task>

<task type="auto">
  <name>Task 2: Add config vars and status display support</name>
  <files>templates/backup-config.sh, templates/backup-config.yaml</files>
  <action>
Add Docker Volume Backup config section to both config templates:

**In templates/backup-config.sh** — Add after the existing Docker database section (near BACKUP_DOCKER_DATABASES if present, otherwise after CLOUD section):

```bash
# ==============================================================================
# DOCKER VOLUME BACKUP
# ==============================================================================

# Enable Docker named volume backup (true/false)
# Automatically detects volumes from docker-compose/compose files
BACKUP_DOCKER_VOLUMES=false

# Volumes to include (comma-separated, empty = all named volumes)
# Example: "myapp_pgdata,myapp_uploads"
DOCKER_VOLUME_INCLUDES=""

# Volumes to exclude (comma-separated, supports wildcards)
# Example: "*_cache,*_node_modules,*_tmp"
DOCKER_VOLUME_EXCLUDES=""
```

**In templates/backup-config.yaml** — Add equivalent YAML section following existing format:

```yaml
# Docker Volume Backup
docker_volume:
  enabled: false
  includes: ""
  excludes: ""
```

NOTE: Reuse existing AUTO_START_DOCKER and STOP_DOCKER_AFTER_BACKUP vars from database-detector.sh — don't duplicate them. These already control Docker lifecycle for both database and volume backups.
  </action>
  <verify>grep "BACKUP_DOCKER_VOLUMES" templates/backup-config.sh returns the new section; grep "docker_volume" templates/backup-config.yaml returns the YAML equivalent</verify>
  <done>Both config templates include Docker volume backup section with BACKUP_DOCKER_VOLUMES, DOCKER_VOLUME_INCLUDES, DOCKER_VOLUME_EXCLUDES</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -n lib/features/docker-volumes.sh` passes
- [ ] Include guard follows encryption.sh pattern
- [ ] All 9 core functions defined
- [ ] Config templates updated with Docker volume section
- [ ] No Bash 4+ features used (no associative arrays, no ${var,,})
- [ ] All variable expansions quoted
</verification>

<success_criteria>

- lib/features/docker-volumes.sh exists with complete detection, backup, and restore functions
- Config templates include Docker volume backup configuration
- Module follows established feature library patterns (include guard, log_set_context)
- Encryption integration handled (encrypt .tar.gz to .tar.gz.age when enabled)
- No bash syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-docker-volume-backup/24-01-SUMMARY.md`
</output>
