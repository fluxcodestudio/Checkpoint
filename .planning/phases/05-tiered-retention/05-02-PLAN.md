---
phase: 05-tiered-retention
plan: 02
type: execute
---

<objective>
Integrate tiered retention into cleanup infrastructure and automate pruning.

Purpose: Connect the retention policy engine to backup-cleanup.sh and add automatic pruning to the daemon cycle.
Output: Updated cleanup with tiered mode, automatic pruning on daemon runs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
@.planning/phases/05-tiered-retention/05-01-SUMMARY.md

**Key files:**
@lib/retention-policy.sh - tiered retention functions from 05-01
@bin/backup-cleanup.sh - existing cleanup with age-based retention
@bin/backup-daemon.sh - existing daemon for background processing

**Constraining decisions:**
- 05-01: Tiered retention tiers (hourly 24h, daily 7d, weekly 4w, monthly 12m)
- Phase 01-02: Silent fallback pattern (don't interrupt user)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate tiered retention into backup-cleanup.sh</name>
  <files>bin/backup-cleanup.sh</files>
  <action>
Update bin/backup-cleanup.sh to add tiered retention mode:

1. Add --tiered flag to command line options:

```bash
# Near existing flags
TIERED_MODE=false

# In case statement
--tiered)
    TIERED_MODE=true
    shift
    ;;
```

2. Add to help text:

```
  --tiered              Use Time Machine-style tiered retention (hourly/daily/weekly/monthly)
```

3. Load retention-policy.sh after backup-lib.sh:

```bash
# After backup-lib.sh loading
if [ -f "$LIB_DIR/retention-policy.sh" ]; then
    source "$LIB_DIR/retention-policy.sh"
fi
```

4. Add tiered cleanup function:

```bash
# Execute tiered retention cleanup
execute_tiered_cleanup() {
    local dry_run="${1:-false}"
    local deleted_count=0
    local freed_size=0

    color_bold "Tiered Retention Cleanup"
    echo ""

    # Show current retention policy
    color_cyan "Retention policy:"
    echo "  Hourly:  Keep all for ${RETENTION_HOURLY_HOURS}h"
    echo "  Daily:   Keep 1/day for ${RETENTION_DAILY_DAYS} days"
    echo "  Weekly:  Keep 1/week for ${RETENTION_WEEKLY_WEEKS} weeks"
    echo "  Monthly: Keep 1/month for ${RETENTION_MONTHLY_MONTHS} months"
    echo ""

    # Process archived files
    if [ "$DATABASE_ONLY" = "false" ] && [ -d "$ARCHIVED_DIR" ]; then
        color_cyan "Analyzing archived files..."
        local stats=$(get_retention_stats "$ARCHIVED_DIR")
        echo "  Current distribution: $stats"

        local savings=$(calculate_tiered_savings "$ARCHIVED_DIR" "*")
        local savings_formatted=$(format_bytes "$savings")

        if [ "$savings" -gt 0 ]; then
            if [ "$dry_run" = "true" ]; then
                color_cyan "  [DRY RUN] Would free: $savings_formatted"
            else
                while IFS= read -r file; do
                    [[ -z "$file" ]] && continue
                    local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
                    if rm -f "$file" 2>/dev/null; then
                        ((deleted_count++))
                        freed_size=$((freed_size + size))
                    fi
                done < <(find_tiered_pruning_candidates "$ARCHIVED_DIR" "*")

                # Clean empty directories
                find "$ARCHIVED_DIR" -type d -empty -delete 2>/dev/null || true

                color_green "  ✅ Freed: $savings_formatted"
            fi
        else
            color_green "  ✅ No files need pruning"
        fi
        echo ""
    fi

    # Process database backups
    if [ "$FILES_ONLY" = "false" ] && [ -d "$DATABASE_DIR" ]; then
        color_cyan "Analyzing database backups..."
        local stats=$(get_retention_stats "$DATABASE_DIR")
        echo "  Current distribution: $stats"

        local savings=$(calculate_tiered_savings "$DATABASE_DIR" "*.db.gz")
        local savings_formatted=$(format_bytes "$savings")

        if [ "$savings" -gt 0 ]; then
            if [ "$dry_run" = "true" ]; then
                color_cyan "  [DRY RUN] Would free: $savings_formatted"
            else
                while IFS= read -r file; do
                    [[ -z "$file" ]] && continue
                    local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
                    if rm -f "$file" 2>/dev/null; then
                        ((deleted_count++))
                        freed_size=$((freed_size + size))
                    fi
                done < <(find_tiered_pruning_candidates "$DATABASE_DIR" "*.db.gz")

                color_green "  ✅ Freed: $savings_formatted"
            fi
        else
            color_green "  ✅ No databases need pruning"
        fi
        echo ""
    fi

    if [ "$dry_run" = "false" ] && [ $deleted_count -gt 0 ]; then
        audit_cleanup "TIERED" "$deleted_count" "$(format_bytes "$freed_size")"
        color_green "Total pruned: $deleted_count files ($(format_bytes "$freed_size"))"
    fi

    return 0
}
```

5. Add tiered mode execution path (after CLOUD_ONLY check):

```bash
# Tiered retention mode
if [ "$TIERED_MODE" = "true" ]; then
    if [ "$DRY_RUN" = "true" ]; then
        execute_tiered_cleanup "true"
    else
        execute_tiered_cleanup "false"
    fi
    echo ""
    color_green "✅ Tiered cleanup complete"
    exit 0
fi
```
  </action>
  <verify>grep -A3 "TIERED_MODE" bin/backup-cleanup.sh shows flag handling && grep -c "execute_tiered_cleanup" bin/backup-cleanup.sh shows 1+ match</verify>
  <done>backup-cleanup.sh has --tiered flag and execute_tiered_cleanup() function</done>
</task>

<task type="auto">
  <name>Task 2: Add automatic pruning to backup daemon</name>
  <files>bin/backup-daemon.sh</files>
  <action>
Update bin/backup-daemon.sh to run tiered cleanup periodically.

1. Add cleanup interval (run every 6 hours = every 6th daemon cycle if hourly):

Near other configuration:
```bash
# Tiered cleanup interval (in daemon cycles, e.g., 6 = every 6 hours if hourly daemon)
CLEANUP_INTERVAL="${CLEANUP_INTERVAL:-6}"
CLEANUP_COUNTER=0
```

2. Load retention-policy.sh:

```bash
# After backup-lib.sh loading
if [ -f "$LIB_DIR/retention-policy.sh" ]; then
    source "$LIB_DIR/retention-policy.sh"
fi
```

3. Add cleanup function:

```bash
# Run tiered retention cleanup (silent, non-blocking)
run_tiered_cleanup() {
    local log_file="${STATE_DIR:-$HOME/.claudecode-backups/state}/cleanup.log"

    # Only run if retention-policy.sh is available
    if ! command -v find_tiered_pruning_candidates &>/dev/null; then
        return 0
    fi

    {
        echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] Starting tiered cleanup"

        local total_pruned=0
        local total_freed=0

        # Process each registered project
        while IFS= read -r project_dir; do
            [[ -z "$project_dir" ]] && continue
            [[ ! -d "$project_dir" ]] && continue

            local config="$project_dir/.backup-config.sh"
            [[ ! -f "$config" ]] && continue

            # Load project config
            source "$config"

            # Prune archived files
            if [[ -d "$ARCHIVED_DIR" ]]; then
                while IFS= read -r file; do
                    [[ -z "$file" ]] && continue
                    local size=$(stat -f%z "$file" 2>/dev/null || echo 0)
                    if rm -f "$file" 2>/dev/null; then
                        ((total_pruned++))
                        total_freed=$((total_freed + size))
                    fi
                done < <(find_tiered_pruning_candidates "$ARCHIVED_DIR" "*" 2>/dev/null)

                # Clean empty directories
                find "$ARCHIVED_DIR" -type d -empty -delete 2>/dev/null || true
            fi

            # Prune database backups
            if [[ -d "$DATABASE_DIR" ]]; then
                while IFS= read -r file; do
                    [[ -z "$file" ]] && continue
                    local size=$(stat -f%z "$file" 2>/dev/null || echo 0)
                    if rm -f "$file" 2>/dev/null; then
                        ((total_pruned++))
                        total_freed=$((total_freed + size))
                    fi
                done < <(find_tiered_pruning_candidates "$DATABASE_DIR" "*.db.gz" 2>/dev/null)
            fi
        done < <(list_registered_projects 2>/dev/null || echo "")

        echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] Cleanup complete: $total_pruned files, $total_freed bytes freed"
    } >> "$log_file" 2>&1 &
}
```

4. Call cleanup in daemon loop (add after backup processing):

```bash
# Increment cleanup counter and run if interval reached
((CLEANUP_COUNTER++))
if [[ $CLEANUP_COUNTER -ge $CLEANUP_INTERVAL ]]; then
    run_tiered_cleanup
    CLEANUP_COUNTER=0
fi
```

This runs tiered cleanup:
- Every 6 daemon cycles (6 hours if hourly daemon)
- In background (non-blocking)
- Silently (logs to file only)
- Across all registered projects
  </action>
  <verify>grep -c "run_tiered_cleanup\|CLEANUP_INTERVAL" bin/backup-daemon.sh shows 2+ matches && grep -c "find_tiered_pruning_candidates" bin/backup-daemon.sh shows 1+ match</verify>
  <done>Daemon runs tiered cleanup every 6 cycles, silently in background</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] backup-cleanup.sh has --tiered flag
- [ ] backup-cleanup.sh --tiered --dry-run shows tiered analysis
- [ ] backup-daemon.sh has cleanup interval and run_tiered_cleanup()
- [ ] No syntax errors: bash -n bin/backup-cleanup.sh && bash -n bin/backup-daemon.sh
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Tiered retention integrated into cleanup and daemon
- Phase 5 complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-tiered-retention/05-02-SUMMARY.md`

Update STATE.md:
- Phase: 5 complete
- Next: Phase 6 (Dashboard & Monitoring)
</output>
