---
phase: 04-fallback-chain
plan: 01
type: execute
---

<objective>
Implement health checking for cloud folder availability and integrate rclone API as a middle fallback tier.

Purpose: Enable graceful degradation when cloud-synced folder is unavailable — try direct rclone upload before falling back to local-only.
Output: Enhanced resolve_backup_destinations() with three-tier fallback: cloud folder → rclone API → local.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase context:**
@.planning/phases/01-cloud-destination/01-02-SUMMARY.md

**Key files:**
@lib/backup-lib.sh - resolve_backup_destinations() at line ~2449
@lib/cloud-backup.sh - rclone infrastructure (cloud_upload, test_rclone_connection)

**Tech stack available:**
- resolve_backup_destinations() with PRIMARY_*/SECONDARY_* pattern
- cloud-backup.sh with rclone upload functions
- Graceful fallback pattern (cloud fails → local)

**Established patterns:**
- PRIMARY_* as source of truth for destinations
- Dual-write when CLOUD_FOLDER_ALSO_LOCAL=true
- Silent fallback with warning log

**Constraining decisions:**
- Phase 01-02: "Fallback silently to local on cloud write failure"
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cloud folder health check function</name>
  <files>lib/backup-lib.sh</files>
  <action>
Add check_cloud_folder_health() function near resolve_backup_destinations():

```bash
# Check if cloud folder is available and writable
# Returns: 0 if healthy, 1 if unavailable
check_cloud_folder_health() {
    local cloud_dir="${CLOUD_BACKUP_DIR:-}"

    # No cloud folder configured
    if [[ -z "$cloud_dir" ]]; then
        return 1
    fi

    # Directory doesn't exist
    if [[ ! -d "$cloud_dir" ]]; then
        return 1
    fi

    # Test write access with temp file
    local test_file="$cloud_dir/.checkpoint-health-check"
    if ! touch "$test_file" 2>/dev/null; then
        return 1
    fi
    rm -f "$test_file" 2>/dev/null

    return 0
}
```

This function:
- Returns early if no cloud folder configured
- Checks directory exists
- Validates write access with temp file (catches permission issues, unmounted drives)
- Cleans up test file
  </action>
  <verify>grep -A15 "check_cloud_folder_health" lib/backup-lib.sh shows complete function</verify>
  <done>check_cloud_folder_health() exists and returns 0/1 based on cloud folder availability</done>
</task>

<task type="auto">
  <name>Task 2: Integrate rclone API as middle fallback tier</name>
  <files>lib/backup-lib.sh</files>
  <action>
Update resolve_backup_destinations() to implement three-tier fallback:

1. After cloud folder detection block (around line 2531), add rclone fallback check:

```bash
    # TIER 1: Cloud folder available - use it as primary
    if check_cloud_folder_health; then
        PRIMARY_BACKUP_DIR="$CLOUD_BACKUP_DIR"
        # ... existing cloud folder setup ...
    # TIER 2: Cloud folder unavailable but rclone configured - try direct API
    elif [[ "${CLOUD_ENABLED:-false}" == "true" ]] && check_rclone_installed 2>/dev/null; then
        backup_log "Cloud folder unavailable, attempting rclone API fallback" "WARN"

        # Use local as primary, rclone will sync asynchronously
        PRIMARY_BACKUP_DIR="$local_backup_dir"
        PRIMARY_FILES_DIR="$PRIMARY_BACKUP_DIR/files"
        PRIMARY_ARCHIVED_DIR="$PRIMARY_BACKUP_DIR/archived"
        PRIMARY_DATABASE_DIR="$PRIMARY_BACKUP_DIR/databases"

        # Mark for rclone sync after backup completes
        export RCLONE_SYNC_PENDING=true

        SECONDARY_BACKUP_DIR=""
        SECONDARY_FILES_DIR=""
        SECONDARY_ARCHIVED_DIR=""
        SECONDARY_DATABASE_DIR=""

        export PRIMARY_BACKUP_DIR PRIMARY_FILES_DIR PRIMARY_ARCHIVED_DIR PRIMARY_DATABASE_DIR
        export SECONDARY_BACKUP_DIR SECONDARY_FILES_DIR SECONDARY_ARCHIVED_DIR SECONDARY_DATABASE_DIR
        return 0
    # TIER 3: Neither available - local only
    else
        backup_log "Cloud folder and rclone unavailable, using local backup only" "WARN"
        PRIMARY_BACKUP_DIR="$local_backup_dir"
        # ... existing local-only setup ...
    fi
```

2. Source cloud-backup.sh at top of backup-lib.sh if not already sourced:

```bash
# Near the top of backup-lib.sh, after set -euo pipefail
_ensure_cloud_backup_loaded() {
    if ! declare -f check_rclone_installed &>/dev/null; then
        local lib_dir
        lib_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        if [[ -f "$lib_dir/cloud-backup.sh" ]]; then
            source "$lib_dir/cloud-backup.sh"
        fi
    fi
}
```

3. Call _ensure_cloud_backup_loaded at start of resolve_backup_destinations().

The pattern is:
- Tier 1: Cloud folder healthy → write directly (auto-syncs via Dropbox/GDrive)
- Tier 2: Cloud folder down + rclone configured → write local, mark RCLONE_SYNC_PENDING
- Tier 3: Both unavailable → local only (queue will handle in 04-02)
  </action>
  <verify>grep -B2 -A10 "RCLONE_SYNC_PENDING" lib/backup-lib.sh shows fallback logic</verify>
  <done>resolve_backup_destinations() checks cloud health first, falls back to rclone tier, then local</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] check_cloud_folder_health() function exists and is callable
- [ ] resolve_backup_destinations() implements three-tier fallback
- [ ] RCLONE_SYNC_PENDING export is set when rclone fallback triggered
- [ ] No syntax errors: bash -n lib/backup-lib.sh passes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Three-tier fallback logic in place: cloud folder → rclone → local
- Existing backup-now.sh continues to work (no breaking changes)
</success_criteria>

<output>
After completion, create `.planning/phases/04-fallback-chain/04-01-SUMMARY.md`
</output>
