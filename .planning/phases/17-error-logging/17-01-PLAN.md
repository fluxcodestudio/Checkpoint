---
phase: 17-error-logging
plan: 01
type: execute
---

<objective>
Create the centralized logging module with log levels, size-based rotation, and integrate it into the existing module loader and config system.

Purpose: Establish the logging foundation that all scripts will use — before migrating any 2>/dev/null occurrences, the infrastructure must exist and be wired into the module system.
Output: Working `lib/core/logging.sh` module with log levels, rotation, debug toggle; integrated into backup-lib.sh loader and config.sh defaults; backward-compatible backup_log() in output.sh.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-error-logging/17-RESEARCH.md

# Key files to read before implementing:
@lib/backup-lib.sh
@lib/core/output.sh
@lib/core/config.sh
@lib/core/error-codes.sh
@lib/platform/compat.sh

# Auto-selected summaries (module system + verification):
@.planning/phases/11-modularize-foundation/11-01-SUMMARY.md
@.planning/phases/16-backup-verification/16-01-SUMMARY.md

**Tech stack available:** bash 3.2+, existing module loader, include guards, platform compat layer (get_file_size)
**Established patterns:** Include guard with `_CHECKPOINT_*`, `@requires/@provides` header comments, `_CHECKPOINT_LIB_DIR` for path resolution
**Constraining decisions:**
- [Phase 11]: Module loader sources core/ modules first, then ops/, ui/, platform/, features/
- [Phase 15]: Platform compat layer provides get_file_size() for cross-platform file size
- [Phase 16]: Error codes use EVER001-006 pattern; new logging errors should follow ELOG* if needed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/core/logging.sh — centralized logging module</name>
  <files>lib/core/logging.sh</files>
  <action>
Create `lib/core/logging.sh` following existing module patterns (include guard, @requires/@provides header, _CHECKPOINT_LIB_DIR).

**Log level constants:**
- LOG_LEVEL_ERROR=0, LOG_LEVEL_WARN=1, LOG_LEVEL_INFO=2, LOG_LEVEL_DEBUG=3, LOG_LEVEL_TRACE=4
- Use `readonly` for constants
- LOG_LEVEL_NAMES array: ("ERROR" "WARN " "INFO " "DEBUG" "TRACE")

**CHECKPOINT_LOG_LEVEL variable:**
- Default: `${CHECKPOINT_LOG_LEVEL:-$LOG_LEVEL_INFO}` (read from env, default INFO)
- NOT readonly — must be modifiable at runtime (for SIGUSR1 toggle, --debug flag)

**init_logging() function:**
- Args: $1 = log_file path (optional, defaults to LOG_FILE or /tmp/checkpoint.log), $2 = max_size in bytes (optional, defaults to 10485760 = 10MB)
- Store in `_CHECKPOINT_LOG_FILE` module variable
- Create parent directory with `mkdir -p` (keep 2>/dev/null here — legitimate use for mkdir)
- Call `_rotate_log` before starting

**Core _log() function:**
- Args: $1 = numeric level, $2 = level name string, remaining = message
- Guard: `(( CHECKPOINT_LOG_LEVEL >= level ))` — skip if below threshold
- Format: `[YYYY-MM-DD HH:MM:SS] [LEVEL] [context] message`
- Use `$(date '+%Y-%m-%d %H:%M:%S')` for timestamp (NOT printf '%()T' — bash 3.2 compat)
- Context label from `_CHECKPOINT_LOG_CONTEXT` variable (default: "main")
- Write with `printf` to `$_CHECKPOINT_LOG_FILE` using append redirect `>>`
- The `2>/dev/null || true` on the printf itself is fine — don't fail backup because logging failed

**Convenience functions:**
- `log_error()` — calls `_log $LOG_LEVEL_ERROR "ERROR" "$@"`
- `log_warn()` — calls `_log $LOG_LEVEL_WARN "WARN " "$@"`
- `log_info()` — calls `_log $LOG_LEVEL_INFO "INFO " "$@"`
- `log_debug()` — calls `_log $LOG_LEVEL_DEBUG "DEBUG" "$@"`
- `log_trace()` — calls `_log $LOG_LEVEL_TRACE "TRACE" "$@"`

**log_set_context() function:**
- Args: $1 = context string (e.g., "backup-now", "daemon", "restore")
- Sets `_CHECKPOINT_LOG_CONTEXT="$1"`

**_rotate_log() function:**
- Args: $1 = log_file, $2 = max_size in bytes
- Guard: `[[ -f "$log_file" ]] || return 0`
- Get file size via `get_file_size` from platform/compat.sh (already available in module system)
  - Fallback: `wc -c < "$log_file"` if get_file_size not available (defensive)
- If size > max_size: rotate .1 through .5 (shift existing, move current to .1, truncate current)
- Use `for ((i=max_files-1; i>=1; i--))` loop — bash 3.2 compatible
- max_files=5 (hardcoded, 5 rotated files = 50MB cap at 10MB each)

**parse_log_flags() function:**
- Args: "$@" (pass-through from CLI argument list)
- Scans for: --debug → LOG_LEVEL_DEBUG, --trace → LOG_LEVEL_TRACE, --quiet → LOG_LEVEL_ERROR
- Sets CHECKPOINT_LOG_LEVEL accordingly
- Does NOT consume arguments (just scans, caller's shift loop handles consumption)

**SIGUSR1 toggle function:**
- `_toggle_debug_level()` — toggles between current level and DEBUG
- Scripts that want this (daemon) call: `trap '_toggle_debug_level' USR1`

**What to avoid and WHY:**
- Do NOT use associative arrays — bash 3.2 doesn't support them
- Do NOT use `printf '%(%Y-%m-%d)T'` — bash 4.2+ only
- Do NOT use FD-based exec redirect (`exec N>>$LOG_FILE`) — complicates error handling with set -e and doesn't work reliably across subshells in bash 3.2
- Do NOT make this module depend on config.sh — logging must load BEFORE config (to log config load errors). It should be self-contained with env var defaults.
- Do NOT echo to stdout from _log() — logging is silent to the user; only writes to file. CLI scripts handle their own user-facing output.
  </action>
  <verify>
1. Source the module standalone: `bash -c 'source lib/core/logging.sh; log_info "test message"'` — should not error
2. Verify bash 3.2 compat: `/bin/bash -c 'source lib/core/logging.sh; log_debug "should not appear"'` — no errors even on macOS default bash
3. Check include guard works: source twice without error
4. Verify rotation: create a 1-byte max test, write messages, check .1 file exists
  </verify>
  <done>
- lib/core/logging.sh exists with include guard, log levels, init_logging, _log, 5 convenience functions, log_set_context, _rotate_log, parse_log_flags, _toggle_debug_level
- Module is self-contained (no dependency on config.sh or output.sh)
- All functions work on bash 3.2
- Log level filtering works (DEBUG messages not written at INFO level)
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate logging into module loader, config, and output</name>
  <files>lib/backup-lib.sh, lib/core/config.sh, lib/core/output.sh</files>
  <action>
**1. Update lib/backup-lib.sh module loader:**
- Add `source "$_CHECKPOINT_LIB_DIR/core/logging.sh"` as the FIRST core module (before error-codes.sh)
- Logging must load first so all other modules can use log_debug/log_error
- After loading all modules, call `init_logging` with default paths (the config will have been loaded by then, so LOG_FILE is available)
- Actually, since config hasn't loaded yet at source time, add an `_init_checkpoint_logging()` function at the end of backup-lib.sh that scripts call after load_backup_config(). This function calls `init_logging "$LOG_FILE"` with the config-provided log path.

**2. Update lib/core/config.sh:**
- In the existing defaults section (after load_backup_config), add:
  - `CHECKPOINT_LOG_LEVEL="${CHECKPOINT_LOG_LEVEL:-2}"` (default INFO)
  - `CHECKPOINT_LOG_MAX_SIZE="${CHECKPOINT_LOG_MAX_SIZE:-10485760}"` (10MB)
- These provide config file overrides while preserving env var priority (env > config > default)
- Do NOT add new functions — just default values alongside existing config defaults

**3. Update lib/core/output.sh backup_log() function:**
- Keep backup_log() signature unchanged (backward compatible)
- Add delegation to new logging module: after existing stdout echo, also call the appropriate log_* function based on level parameter
- Map: "INFO" → log_info(), "WARN" → log_warn(), "ERROR" → log_error()
- This means existing backup_log() calls automatically get structured logging too
- Keep the existing file-write logic in backup_log() for now — it will be removed in a later migration plan once all callers switch to log_* functions directly

**What to avoid and WHY:**
- Do NOT remove the existing backup_log() function — it's called from many scripts. Keep it working.
- Do NOT change the module load order of existing modules — only INSERT logging.sh before the others
- Do NOT call init_logging at source time — config isn't loaded yet. Provide _init_checkpoint_logging() for scripts to call after config load.
  </action>
  <verify>
1. `bash -c 'source lib/backup-lib.sh && echo "All modules loaded"'` — no errors
2. Verify logging.sh is loaded first: `bash -c 'source lib/backup-lib.sh && type log_debug'` — should show function
3. Verify backup_log still works: `bash -c 'source lib/backup-lib.sh && backup_log "test" INFO'` — should output to stdout
4. Verify config defaults: `bash -c 'source lib/backup-lib.sh && echo $CHECKPOINT_LOG_LEVEL'` — should show 2 (INFO)
  </verify>
  <done>
- logging.sh loaded first in backup-lib.sh module chain
- config.sh has CHECKPOINT_LOG_LEVEL and CHECKPOINT_LOG_MAX_SIZE defaults
- backup_log() in output.sh delegates to log_info/warn/error for structured file logging
- _init_checkpoint_logging() available for scripts to call after config load
- All existing scripts continue to work without changes (backward compatible)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -c 'source lib/backup-lib.sh'` succeeds without errors
- [ ] Log level filtering works: DEBUG messages suppressed at INFO level
- [ ] Log rotation works: files rotate when exceeding max size
- [ ] parse_log_flags correctly sets level from --debug/--trace/--quiet
- [ ] backup_log() backward compatibility: existing calls produce same stdout output
- [ ] No bash 3.2 compatibility issues: test with `/bin/bash`
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Logging module is self-contained and loads before all other modules
- Backward compatibility maintained for all existing scripts
</success_criteria>

<output>
After completion, create `.planning/phases/17-error-logging/17-01-SUMMARY.md`
</output>
