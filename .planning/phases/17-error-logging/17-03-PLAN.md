---
phase: 17-error-logging
plan: 03
type: execute
---

<objective>
Migrate library modules (lib/) from 2>/dev/null to structured logging — covering the critical-path modules (database-detector, cloud-backup, platform/daemon-manager) and all feature/ops modules.

Purpose: Library modules contain the business logic for backup operations. Their error suppression is the most dangerous because failures in database backup, cloud sync, and daemon management are hidden from diagnostics.
Output: All active lib/ modules use structured logging for diagnostic stderr; legitimate 2>/dev/null retained.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-error-logging/17-RESEARCH.md
@.planning/phases/17-error-logging/17-01-SUMMARY.md
@.planning/phases/17-error-logging/17-02-SUMMARY.md

# Key files to modify:
@lib/database-detector.sh
@lib/cloud-backup.sh
@lib/platform/daemon-manager.sh
@lib/features/verification.sh
@lib/features/cleanup.sh
@lib/features/cloud-destinations.sh
@lib/features/restore.sh
@lib/ops/file-ops.sh
@lib/ops/state.sh
@lib/ops/init.sh
@lib/auto-configure.sh
@lib/core/logging.sh

**Categorization rules (from 17-RESEARCH.md):**
- KEEP: `command -v`, `type`, `hash`, read-with-fallback (`cat file 2>/dev/null || ""`), platform detection, include guard patterns
- REPLACE: sqlite3 operations, gzip, rsync, cp/mv in backup paths, find with -delete, launchctl/systemctl commands → capture stderr to log_debug or redirect to log file
- REDIRECT: mkdir -p, stat operations → keep 2>/dev/null but add log_debug on failure
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate critical-path library modules</name>
  <files>lib/database-detector.sh, lib/cloud-backup.sh, lib/platform/daemon-manager.sh</files>
  <action>
These three modules have the highest error-hiding risk. Read each fully, categorize every 2>/dev/null, then migrate.

**lib/database-detector.sh (~41 occurrences):**
- CRITICAL: sqlite3 backup operations (`sqlite3 "$db_path" ".backup '$temp_db'" 2>/dev/null`) — replace with stderr capture: `if ! db_err=$(sqlite3 ... 2>&1); then log_debug "SQLite backup failed for $db_path: $db_err"; fi`
- CRITICAL: gzip operations on database dumps — capture compression errors to log_debug
- KEEP: command -v checks for sqlite3, pg_dump, mysqldump, mongodump
- KEEP: Port checking with netstat/lsof (expected failures on no-process)
- Add `log_set_context "db-detect"` near the top (after include guard)
- Add log_info for successful database detections, log_warn for failed backup attempts
- Add log_debug for each database detection attempt result

**lib/cloud-backup.sh (~9 occurrences):**
- REPLACE: rclone sync operations — capture stderr to log_debug on failure
- KEEP: command -v rclone check
- Add `log_set_context "cloud"` near the top
- Add log_info for successful cloud syncs, log_warn for failures with fallback

**lib/platform/daemon-manager.sh (~49 occurrences):**
- REPLACE: launchctl list/load/unload operations — capture stderr, these fail with useful error messages about why a service isn't loading
- REPLACE: systemctl status/start/stop/enable operations — same pattern
- KEEP: launchctl list piped to grep (testing service existence)
- KEEP: command -v checks for launchctl, systemctl, crontab
- Add `log_set_context "daemon-mgr"` near the top
- Pattern for service commands: `if ! svc_err=$(launchctl load "$plist" 2>&1); then log_debug "launchctl load failed: $svc_err"; fi`

**What to avoid and WHY:**
- Do NOT change the error handling flow — if a function returns 1 on failure, keep that behavior
- Do NOT log passwords or credentials — database-detector may have connection strings
- Do NOT add log_debug inside tight detection loops (e.g., scanning many db files) — use log_trace for per-file detail
- Do NOT modify lib/archive/ files — those are archived copies
  </action>
  <verify>
1. `bash -n lib/database-detector.sh` — syntax check
2. `bash -n lib/cloud-backup.sh` — syntax check
3. `bash -n lib/platform/daemon-manager.sh` — syntax check
4. Source modules via backup-lib.sh: `bash -c 'source lib/backup-lib.sh && echo OK'`
5. Grep remaining 2>/dev/null in these files — only KEEP-category should remain
  </verify>
  <done>
- database-detector.sh: sqlite3/gzip/pg_dump/mysqldump/mongodump errors captured to log_debug
- cloud-backup.sh: rclone sync errors captured to log_debug
- daemon-manager.sh: launchctl/systemctl errors captured to log_debug
- All three modules set log context
- Only legitimate 2>/dev/null retained (command -v, pid checks)
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate remaining lib/ modules (features/, ops/, other)</name>
  <files>lib/features/verification.sh, lib/features/cleanup.sh, lib/features/cloud-destinations.sh, lib/features/restore.sh, lib/features/change-detection.sh, lib/features/backup-discovery.sh, lib/features/health-stats.sh, lib/features/malware.sh, lib/features/github-auth.sh, lib/ops/file-ops.sh, lib/ops/state.sh, lib/ops/init.sh, lib/auto-configure.sh, lib/dashboard-status.sh, lib/ui/formatting.sh, lib/ui/time-size-utils.sh, lib/platform/compat.sh</files>
  <action>
Migrate all remaining active lib/ modules. These are lower risk than Task 1 but still suppress useful diagnostic info.

**For each file, apply the standard categorization:**
1. Read the file
2. Identify each 2>/dev/null occurrence
3. Categorize as KEEP, REPLACE, or REDIRECT
4. Apply the appropriate pattern

**Priority modules (more occurrences or higher risk):**
- lib/features/verification.sh (~39 occ) — sqlite3 integrity checks, file stat operations. Log verification failures to log_debug.
- lib/features/cleanup.sh (~14 occ) — find -delete operations are CRITICAL. Redirect stderr to log file: `find ... -delete 2>>"${_CHECKPOINT_LOG_FILE:-/dev/null}"`
- lib/features/cloud-destinations.sh — mkdir -p for backup dirs. Keep 2>/dev/null on mkdir but add log_debug on failure branch.
- lib/features/restore.sh — cp operations for restore. CRITICAL: capture restore failures to log_error (not debug — restore failures are user-visible errors).
- lib/auto-configure.sh (~30 occ) — detection heuristics. Many are legitimate KEEP (checking if dirs/files exist).

**Lower priority (fewer occurrences, lower risk):**
- lib/ops/file-ops.sh — grep/stat with fallback. Mostly KEEP.
- lib/ops/state.sh — state file reads. Mostly KEEP (read-with-fallback pattern).
- lib/ops/init.sh — directory creation. REDIRECT pattern.
- lib/features/change-detection.sh — git operations. REPLACE pattern.
- lib/features/health-stats.sh — stat/read operations. Mostly KEEP.
- lib/features/backup-discovery.sh — file scanning. Mostly KEEP.
- lib/features/malware.sh — file checks. Mostly KEEP.
- lib/features/github-auth.sh — git/gh operations. REPLACE pattern.
- lib/dashboard-status.sh — reading log/state files. Mostly KEEP.
- lib/ui/ modules — likely zero or very few, probably all KEEP.
- lib/platform/compat.sh — platform detection. All KEEP.

**Pattern reference for quick migration:**
```bash
# KEEP (don't touch):
command -v X 2>/dev/null
cat "$file" 2>/dev/null || echo ""
date +%s%3N 2>/dev/null || date +%s

# REPLACE (diagnostic value):
# Before: some_command 2>/dev/null
# After:  if ! _err=$(some_command 2>&1); then log_debug "some_command: $_err"; fi
# Or simpler for fire-and-forget: some_command 2>>"${_CHECKPOINT_LOG_FILE:-/dev/null}"

# REDIRECT (expected failure with logging):
# Before: mkdir -p "$dir" 2>/dev/null || handle_error
# After:  mkdir -p "$dir" 2>>"${_CHECKPOINT_LOG_FILE:-/dev/null}" || { log_debug "mkdir failed: $dir"; handle_error; }
```

**What to avoid and WHY:**
- Do NOT spend excessive time on lib/archive/ files — they're archived
- Do NOT modify test files — they have their own 2>/dev/null for test isolation
- Do NOT add log_set_context to every tiny module — only modules with significant operations (verification, cleanup, restore, cloud-destinations)
  </action>
  <verify>
1. `bash -c 'source lib/backup-lib.sh && echo OK'` — all modules load without error
2. `bash -n` syntax check on each modified file
3. Grep for 2>/dev/null across all active lib/ files — count should drop significantly from baseline
4. Verify cleanup.sh find -delete now logs to file instead of /dev/null
5. Verify restore.sh cp failures now log_error
  </verify>
  <done>
- All active lib/ modules migrated (features/, ops/, platform/, ui/, auto-configure, dashboard-status)
- Critical operations (cleanup -delete, restore cp, verification sqlite3) now log errors
- Only legitimate 2>/dev/null retained across lib/
- All modules still load via backup-lib.sh without error
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `bash -c 'source lib/backup-lib.sh && echo OK'` — full module chain loads
- [ ] `bash -n` passes on all modified files
- [ ] Critical operations (database backup, cloud sync, daemon management, restore, cleanup) now log diagnostic errors
- [ ] Legitimate 2>/dev/null retained (command -v, platform detection, read-with-fallback)
- [ ] No functionality changes — only where stderr goes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- All active lib/ modules use structured logging for diagnostic stderr
- Critical-path error suppression eliminated
</success_criteria>

<output>
After completion, create `.planning/phases/17-error-logging/17-03-SUMMARY.md`
</output>
